# Story 1.2: Implement Plugin Manager with pluggy

## Epic Context
**Epic:** Epic 1: Component Architecture Foundation  
**Epic Goal:** Establish proper component separation and base interfaces to enable plugin development

## Story Details
**Priority:** Critical  
**Effort:** Large  
**Dependencies:** Story 1.1 (Create Component Directory Structure)

## User Story
As a developer,
I want to implement the plugin manager using pluggy,
so that the system can dynamically load and manage different view types and datasources.

## Acceptance Criteria
1. Plugin manager is implemented with pluggy integration
2. Hook specifications are defined for view and datasource plugins
3. Default plugins (table view, SQLite datasource) are implemented
4. Plugin loading and registration works without application restart

## Integration Verification
- Existing table view continues to work through plugin system
- SQLite datasource continues to work through plugin system
- Plugin manager can discover and load plugins from designated directories

## Technical Requirements

### Plugin Manager Architecture
```python
import pluggy
from typing import Dict, List, Type, Any
from components.views.base_view import BaseView
from components.datasources.base_datasource import BaseDatasource

class PluginManager:
    def __init__(self):
        self.pm = pluggy.PluginManager("nocoflo")
        self.pm.add_hookspecs(ViewHookSpec)
        self.pm.add_hookspecs(DatasourceHookSpec)
        self.load_default_plugins()
        self.load_external_plugins()
    
    def get_available_views(self, table_meta: Dict) -> List[BaseView]:
        """Get available view plugins for a table"""
        pass
    
    def get_datasource(self, datasource_type: str) -> BaseDatasource:
        """Get datasource plugin by type"""
        pass
    
    def register_plugin(self, plugin: Any) -> None:
        """Register a new plugin at runtime"""
        pass
```

### Hook Specifications

#### View Hook Specification
```python
import pluggy
from typing import Type
from components.views.base_view import BaseView

hookspec = pluggy.HookspecMarker("nocoflo")

class ViewHookSpec:
    @hookspec
    def get_view_class(self) -> Type[BaseView]:
        """Return the view class this plugin provides"""
        
    @hookspec  
    def get_view_priority(self) -> int:
        """Return priority for view selection (higher = preferred)"""
        
    @hookspec
    def get_view_name(self) -> str:
        """Return human-readable name for this view"""
        
    @hookspec
    def can_handle_table(self, table_meta: Dict) -> bool:
        """Determine if this view can handle the given table"""
```

#### Datasource Hook Specification
```python
import pluggy
from typing import Type, List
from components.datasources.base_datasource import BaseDatasource

hookspec = pluggy.HookspecMarker("nocoflo")

class DatasourceHookSpec:
    @hookspec
    def get_datasource_class(self) -> Type[BaseDatasource]:
        """Return the datasource class this plugin provides"""
        
    @hookspec
    def get_supported_schemes(self) -> List[str]:
        """Return list of connection string schemes this datasource supports"""
        
    @hookspec
    def get_datasource_name(self) -> str:
        """Return human-readable name for this datasource"""
        
    @hookspec
    def test_connection(self, connection_config: Dict) -> bool:
        """Test connection to datasource"""
```

### Default Plugins

#### Table View Plugin
```python
import pluggy
from components.views.base_view import BaseView
from components.views.table_view import TableView

hookimpl = pluggy.HookimplMarker("nocoflo")

class TableViewPlugin:
    @hookimpl
    def get_view_class(self) -> Type[BaseView]:
        return TableView
    
    @hookimpl
    def get_view_priority(self) -> int:
        return 1  # Default fallback priority
    
    @hookimpl
    def get_view_name(self) -> str:
        return "Table View"
    
    @hookimpl
    def can_handle_table(self, table_meta: Dict) -> bool:
        return True  # Table view can handle any table
```

#### SQLite Datasource Plugin
```python
import pluggy
from components.datasources.base_datasource import BaseDatasource
from components.datasources.sqlite_datasource import SQLiteDatasource

hookimpl = pluggy.HookimplMarker("nocoflo")

class SQLiteDatasourcePlugin:
    @hookimpl
    def get_datasource_class(self) -> Type[BaseDatasource]:
        return SQLiteDatasource
    
    @hookimpl
    def get_supported_schemes(self) -> List[str]:
        return ["sqlite", "sqlite3"]
    
    @hookimpl
    def get_datasource_name(self) -> str:
        return "SQLite"
    
    @hookimpl
    def test_connection(self, connection_config: Dict) -> bool:
        # Test SQLite connection
        pass
```

## Implementation Tasks

### Task 1: Install and Configure pluggy
- [ ] Add pluggy to requirements.txt
- [ ] Install pluggy dependency
- [ ] Create plugin manager configuration

### Task 2: Create Hook Specifications
- [ ] Create `src/plugins/hookspecs.py` with ViewHookSpec
- [ ] Create `src/plugins/hookspecs.py` with DatasourceHookSpec
- [ ] Add proper type hints and docstrings
- [ ] Create hook implementation markers

### Task 3: Implement Plugin Manager
- [ ] Create `src/plugins/plugin_manager.py` with PluginManager class
- [ ] Implement plugin discovery and loading
- [ ] Implement plugin registration system
- [ ] Add error handling for plugin loading failures

### Task 4: Create Default Plugins
- [ ] Create `src/plugins/default/table_view_plugin.py`
- [ ] Create `src/plugins/default/sqlite_datasource_plugin.py`
- [ ] Implement plugin classes with proper hook implementations
- [ ] Add plugin metadata and configuration

### Task 5: Integrate with Application
- [ ] Initialize plugin manager in app startup
- [ ] Update existing code to use plugin system
- [ ] Ensure existing functionality works through plugins
- [ ] Add plugin loading error handling

### Task 6: Plugin Discovery System
- [ ] Implement plugin directory scanning
- [ ] Add plugin validation and security checks
- [ ] Create plugin loading without application restart
- [ ] Add plugin health monitoring

### Task 7: Testing
- [ ] Create unit tests for plugin manager
- [ ] Test plugin loading and registration
- [ ] Test plugin error handling
- [ ] Verify existing functionality works through plugin system

## Definition of Done
- [ ] Plugin manager is implemented with pluggy integration
- [ ] Hook specifications are defined for view and datasource plugins
- [ ] Default plugins (table view, SQLite datasource) are implemented
- [ ] Plugin loading and registration works without application restart
- [ ] All existing functionality works through plugin system
- [ ] Plugin error handling is robust
- [ ] Tests cover plugin manager functionality
- [ ] Documentation is updated for plugin system

## Risk Assessment
**Risk:** Plugin system complexity may introduce bugs in existing functionality
**Mitigation:** Comprehensive testing, gradual rollout, fallback mechanisms for plugin failures

## Dependencies
- Story 1.1: Create Component Directory Structure (must be completed first)

## Next Stories
- Story 1.3: Refactor Authentication and Layout Components
- Story 2.1: Create Chart View Plugin 