# Story 3.3: Create Plugin Development Kit

## Epic Context
**Epic:** Epic 3: Plugin Management and Configuration  
**Epic Goal:** Provide user-friendly interfaces for managing plugins and configurations

## Story Details
**Priority:** Medium  
**Effort:** Large  
**Dependencies:** Story 1.2 (Implement Plugin Manager with pluggy)

## User Story
As a developer,
I want to create comprehensive documentation and tools for plugin development,
so that third-party developers can create custom plugins easily and safely.

## Acceptance Criteria
1. Create comprehensive plugin development documentation
2. Implement plugin template generator
3. Create testing utilities for plugin development
4. Provide example plugins demonstrating best practices
5. Create plugin validation and testing tools

## Integration Verification
- Example plugins work correctly in the system
- Plugin development tools don't impact production functionality
- Documentation enables successful plugin development

## Technical Requirements

### Plugin Development Documentation
```markdown
# Plugin Development Guide

## Overview
This guide explains how to create plugins for Nocoflo. Plugins allow you to extend the system with new view types and datasources.

## Plugin Types

### View Plugins
View plugins provide different ways to display and interact with data:
- **Table View**: Default grid-based view
- **Chart View**: Data visualization with charts
- **Form View**: Single-record editing interface

### Datasource Plugins
Datasource plugins provide access to different data sources:
- **SQLite**: Default local database
- **PostgreSQL**: Enterprise database support
- **MySQL**: Web application database support

## Plugin Structure

### Basic Plugin Structure
```python
import pluggy
from typing import Dict, List, Any, Type
from components.views.base_view import BaseView
from components.datasources.base_datasource import BaseDatasource

hookimpl = pluggy.HookimplMarker("nocoflo")

class MyViewPlugin:
    @hookimpl
    def get_view_class(self) -> Type[BaseView]:
        return MyView
    
    @hookimpl
    def get_view_priority(self) -> int:
        return 1
    
    @hookimpl
    def get_view_name(self) -> str:
        return "My Custom View"
    
    @hookimpl
    def can_handle_table(self, table_meta: Dict) -> bool:
        return self._is_suitable_for_my_view(table_meta)
```

### View Plugin Implementation
```python
class MyView(BaseView):
    def __init__(self, table_id: int, datasource: BaseDatasource):
        super().__init__(table_id, datasource)
        self.config = {}
    
    def render(self) -> None:
        """Render the view"""
        # Your view rendering logic here
        pass
    
    def get_view_name(self) -> str:
        return "My Custom View"
    
    def can_handle_table(self, table_meta: Dict) -> bool:
        # Determine if this view is appropriate for the table
        return True
    
    def get_priority(self) -> int:
        return 1
```

### Datasource Plugin Implementation
```python
class MyDatasource(BaseDatasource):
    def __init__(self, connection_config: Dict):
        self.connection_config = connection_config
        self.connection = None
    
    def connect(self) -> bool:
        """Establish connection to data source"""
        try:
            # Your connection logic here
            return True
        except Exception as e:
            logging.error(f"Connection failed: {str(e)}")
            return False
    
    def get_table_data(self, table_config: Dict, limit: int = 100) -> Tuple[List[str], List[Tuple]]:
        """Retrieve data from source"""
        # Your data retrieval logic here
        pass
    
    def update_cell(self, table_config: Dict, pk_col: str, pk_value: str, column: str, new_value: Any) -> bool:
        """Update cell value"""
        # Your update logic here
        pass
```

## Plugin Development Workflow

### 1. Setup Development Environment
```bash
# Clone the repository
git clone https://github.com/your-org/nocoflo.git
cd nocoflo

# Install development dependencies
pip install -r requirements-dev.txt

# Run the development server
python src/app.py
```

### 2. Create Plugin Structure
```bash
# Use the plugin template generator
python tools/generate_plugin.py --type view --name my_custom_view
python tools/generate_plugin.py --type datasource --name my_datasource
```

### 3. Implement Plugin Logic
- Implement the required interface methods
- Add proper error handling
- Include comprehensive logging
- Add input validation

### 4. Test Your Plugin
```bash
# Run plugin tests
python -m pytest tests/plugins/test_my_plugin.py

# Run integration tests
python -m pytest tests/integration/test_plugin_integration.py
```

### 5. Package and Distribute
```bash
# Create plugin package
python tools/package_plugin.py my_plugin/

# Install plugin
python tools/install_plugin.py my_plugin-1.0.0.zip
```

## Best Practices

### Security
- Never use `eval()` or `exec()`
- Validate all inputs
- Sanitize user data
- Use parameterized queries for databases

### Performance
- Implement caching where appropriate
- Use lazy loading for large datasets
- Monitor memory usage
- Handle timeouts gracefully

### Error Handling
- Catch and log all exceptions
- Provide meaningful error messages
- Implement graceful degradation
- Don't let plugin errors crash the system

### Testing
- Write unit tests for all functions
- Test error conditions
- Test with different data types
- Test performance with large datasets

## Plugin Configuration

### Configuration Schema
```python
PLUGIN_CONFIG_SCHEMA = {
    "type": "object",
    "properties": {
        "enabled": {"type": "boolean", "default": True},
        "priority": {"type": "integer", "minimum": 1, "maximum": 10},
        "settings": {
            "type": "object",
            "properties": {
                "cache_enabled": {"type": "boolean", "default": True},
                "timeout": {"type": "integer", "minimum": 1, "maximum": 300},
                "max_results": {"type": "integer", "minimum": 1, "maximum": 10000}
            }
        }
    }
}
```

### Configuration Example
```python
class MyView(BaseView):
    def __init__(self, table_id: int, datasource: BaseDatasource, config: Dict = None):
        super().__init__(table_id, datasource)
        self.config = config or {}
        self.cache_enabled = self.config.get('cache_enabled', True)
        self.timeout = self.config.get('timeout', 30)
        self.max_results = self.config.get('max_results', 1000)
```

## Troubleshooting

### Common Issues
1. **Plugin not loading**: Check import paths and dependencies
2. **Performance issues**: Monitor memory usage and implement caching
3. **Security errors**: Review security validation requirements
4. **Integration problems**: Test with different data types and sizes

### Debugging Tools
```python
# Enable debug logging
import logging
logging.basicConfig(level=logging.DEBUG)

# Use plugin debugger
from tools.plugin_debugger import PluginDebugger
debugger = PluginDebugger()
debugger.debug_plugin('my_plugin')
```

## Examples

### Simple Chart View Plugin
```python
import plotly.graph_objects as go
from components.views.base_view import BaseView

class SimpleChartView(BaseView):
    def render(self) -> None:
        data = self.datasource.get_table_data(self.table_id)
        
        # Create simple bar chart
        fig = go.Figure(data=[
            go.Bar(x=data['categories'], y=data['values'])
        ])
        
        # Display chart
        ui.plotly(fig)
```

### Custom Datasource Plugin
```python
import requests
from components.datasources.base_datasource import BaseDatasource

class APIDatasource(BaseDatasource):
    def __init__(self, api_url: str, api_key: str):
        self.api_url = api_url
        self.api_key = api_key
    
    def get_table_data(self, table_config: Dict, limit: int = 100):
        response = requests.get(
            f"{self.api_url}/data",
            headers={"Authorization": f"Bearer {self.api_key}"},
            params={"limit": limit}
        )
        response.raise_for_status()
        return response.json()
```

### Plugin Template Generator
```python
# tools/generate_plugin.py
import argparse
import os
import shutil
from pathlib import Path
from typing import Dict, Any

class PluginTemplateGenerator:
    def __init__(self):
        self.templates_dir = Path("tools/templates")
        self.plugins_dir = Path("src/plugins/external")
        
        self.templates = {
            'view': {
                'files': ['__init__.py', 'plugin.py', 'view.py', 'test_plugin.py'],
                'template_dir': 'view_plugin'
            },
            'datasource': {
                'files': ['__init__.py', 'plugin.py', 'datasource.py', 'test_plugin.py'],
                'template_dir': 'datasource_plugin'
            }
        }
    
    def generate_plugin(self, plugin_type: str, plugin_name: str, description: str = ""):
        """Generate plugin from template"""
        if plugin_type not in self.templates:
            raise ValueError(f"Unknown plugin type: {plugin_type}")
        
        # Create plugin directory
        plugin_dir = self.plugins_dir / plugin_name
        plugin_dir.mkdir(parents=True, exist_ok=True)
        
        # Get template configuration
        template_config = self.templates[plugin_type]
        template_dir = self.templates_dir / template_config['template_dir']
        
        # Generate files
        for filename in template_config['files']:
            self._generate_file(template_dir, plugin_dir, filename, {
                'plugin_name': plugin_name,
                'plugin_type': plugin_type,
                'description': description,
                'class_name': self._to_class_name(plugin_name)
            })
        
        # Create README
        self._generate_readme(plugin_dir, plugin_name, description)
        
        print(f"Plugin '{plugin_name}' generated successfully in {plugin_dir}")
    
    def _generate_file(self, template_dir: Path, plugin_dir: Path, filename: str, context: Dict[str, Any]):
        """Generate file from template"""
        template_file = template_dir / f"{filename}.template"
        output_file = plugin_dir / filename
        
        if template_file.exists():
            with open(template_file, 'r') as f:
                content = f.read()
            
            # Replace placeholders
            for key, value in context.items():
                content = content.replace(f"{{{{{key}}}}}", str(value))
            
            with open(output_file, 'w') as f:
                f.write(content)
    
    def _generate_readme(self, plugin_dir: Path, plugin_name: str, description: str):
        """Generate README for plugin"""
        readme_content = f"""# {plugin_name}

{description}

## Installation

Copy this plugin to your Nocoflo plugins directory:

```bash
cp -r {plugin_name} /path/to/nocoflo/src/plugins/external/
```

## Configuration

Add the plugin to your configuration:

```python
PLUGIN_CONFIG = {{
    'enabled_plugins': ['{plugin_name}'],
    # ... other configuration
}}
```

## Usage

The plugin will be automatically loaded and available in the system.

## Development

To modify this plugin:

1. Edit the plugin files in this directory
2. Test your changes: `python -m pytest test_plugin.py`
3. Restart Nocoflo to load changes

## License

[Your License Here]
"""
        
        with open(plugin_dir / "README.md", 'w') as f:
            f.write(readme_content)
    
    def _to_class_name(self, plugin_name: str) -> str:
        """Convert plugin name to class name"""
        return ''.join(word.capitalize() for word in plugin_name.split('_'))

def main():
    parser = argparse.ArgumentParser(description='Generate plugin template')
    parser.add_argument('--type', choices=['view', 'datasource'], required=True,
                       help='Type of plugin to generate')
    parser.add_argument('--name', required=True,
                       help='Name of the plugin')
    parser.add_argument('--description', default='',
                       help='Description of the plugin')
    
    args = parser.parse_args()
    
    generator = PluginTemplateGenerator()
    generator.generate_plugin(args.type, args.name, args.description)

if __name__ == '__main__':
    main()
```

### Plugin Testing Utilities
```python
# tools/plugin_test_utils.py
import unittest
from typing import Dict, List, Any
from unittest.mock import Mock, patch
import tempfile
import shutil
import os

class PluginTestCase(unittest.TestCase):
    """Base class for plugin tests"""
    
    def setUp(self):
        """Set up test environment"""
        self.temp_dir = tempfile.mkdtemp()
        self.plugin_manager = Mock()
        self.datasource = Mock()
        
    def tearDown(self):
        """Clean up test environment"""
        shutil.rmtree(self.temp_dir)
    
    def create_test_data(self, rows: int = 10, columns: int = 5) -> Tuple[List[str], List[Tuple]]:
        """Create test data for plugins"""
        columns = [f'col_{i}' for i in range(columns)]
        data = []
        
        for i in range(rows):
            row = tuple(f'value_{i}_{j}' for j in range(columns))
            data.append(row)
        
        return columns, data
    
    def create_test_table_meta(self, columns: List[str]) -> Dict[str, Any]:
        """Create test table metadata"""
        return {
            'id': 1,
            'name': 'test_table',
            'display_name': 'Test Table',
            'columns': columns,
            'row_count': 100,
            'created_at': '2024-01-01T00:00:00Z',
            'updated_at': '2024-01-01T00:00:00Z'
        }
    
    def assert_view_renders(self, view_class, table_meta: Dict):
        """Assert that view can render without errors"""
        view = view_class(table_meta['id'], self.datasource)
        
        # Mock UI components
        with patch('nicegui.ui') as mock_ui:
            view.render()
            
            # Verify that UI components were created
            self.assertTrue(mock_ui.called)
    
    def assert_datasource_connects(self, datasource_class, config: Dict):
        """Assert that datasource can connect"""
        datasource = datasource_class(config)
        self.assertTrue(datasource.connect())
    
    def assert_plugin_registers(self, plugin_class):
        """Assert that plugin registers correctly"""
        plugin = plugin_class()
        
        # Check that plugin has required methods
        self.assertTrue(hasattr(plugin, 'get_view_class'))
        self.assertTrue(hasattr(plugin, 'get_view_priority'))
        self.assertTrue(hasattr(plugin, 'get_view_name'))
        self.assertTrue(hasattr(plugin, 'can_handle_table'))

class PerformanceTestCase(unittest.TestCase):
    """Base class for performance tests"""
    
    def setUp(self):
        """Set up performance test environment"""
        self.start_time = time.time()
        self.start_memory = psutil.Process().memory_info().rss
    
    def tearDown(self):
        """Record performance metrics"""
        end_time = time.time()
        end_memory = psutil.Process().memory_info().rss
        
        duration = end_time - self.start_time
        memory_usage = end_memory - self.start_memory
        
        print(f"Test duration: {duration:.2f}s")
        print(f"Memory usage: {memory_usage / 1024 / 1024:.2f}MB")
    
    def assert_performance_acceptable(self, max_duration: float = 5.0, max_memory_mb: float = 100.0):
        """Assert that performance is within acceptable limits"""
        end_time = time.time()
        end_memory = psutil.Process().memory_info().rss
        
        duration = end_time - self.start_time
        memory_usage_mb = (end_memory - self.start_memory) / 1024 / 1024
        
        self.assertLess(duration, max_duration, f"Test took too long: {duration:.2f}s")
        self.assertLess(memory_usage_mb, max_memory_mb, f"Memory usage too high: {memory_usage_mb:.2f}MB")

class SecurityTestCase(unittest.TestCase):
    """Base class for security tests"""
    
    def setUp(self):
        """Set up security test environment"""
        self.validator = PluginSecurityValidator()
    
    def assert_plugin_secure(self, plugin_path: str):
        """Assert that plugin passes security validation"""
        result = self.validator.validate_plugin(plugin_path)
        self.assertTrue(result['valid'], f"Plugin failed security validation: {result['errors']}")
        self.assertGreaterEqual(result['security_score'], 70, f"Security score too low: {result['security_score']}")
    
    def assert_input_safe(self, validator: InputValidator, context: str, data: Dict[str, Any]):
        """Assert that input is safe"""
        result = validator.validate_input(context, data)
        self.assertTrue(result['valid'], f"Input validation failed: {result['errors']}")
```

### Example Plugins
```python
# src/plugins/examples/simple_chart_view_plugin.py
import pluggy
from typing import Dict, List, Any, Type
from components.views.base_view import BaseView
import plotly.graph_objects as go
import plotly.express as px

hookimpl = pluggy.HookimplMarker("nocoflo")

class SimpleChartViewPlugin:
    @hookimpl
    def get_view_class(self) -> Type[BaseView]:
        return SimpleChartView
    
    @hookimpl
    def get_view_priority(self) -> int:
        return 2
    
    @hookimpl
    def get_view_name(self) -> str:
        return "Simple Chart View"
    
    @hookimpl
    def can_handle_table(self, table_meta: Dict) -> bool:
        return self._has_numeric_columns(table_meta)
    
    def _has_numeric_columns(self, table_meta: Dict) -> bool:
        """Check if table has numeric columns suitable for charting"""
        columns = table_meta.get('columns', [])
        numeric_patterns = ['amount', 'count', 'number', 'quantity', 'price', 'value']
        
        return any(pattern in col.lower() for col in columns for pattern in numeric_patterns)

class SimpleChartView(BaseView):
    def __init__(self, table_id: int, datasource):
        super().__init__(table_id, datasource)
        self.chart_type = 'bar'
    
    def render(self) -> None:
        """Render simple chart view"""
        # Get data
        columns, data = self.datasource.get_table_data({'table_id': self.table_id})
        
        if not data:
            ui.label('No data available for charting')
            return
        
        # Find numeric columns
        numeric_columns = self._find_numeric_columns(columns, data)
        
        if not numeric_columns:
            ui.label('No numeric columns found for charting')
            return
        
        # Create chart
        chart_data = self._prepare_chart_data(columns, data, numeric_columns[0])
        
        if self.chart_type == 'bar':
            fig = go.Figure(data=[
                go.Bar(x=chart_data['x'], y=chart_data['y'])
            ])
        elif self.chart_type == 'line':
            fig = go.Figure(data=[
                go.Scatter(x=chart_data['x'], y=chart_data['y'], mode='lines+markers')
            ])
        else:
            fig = go.Figure(data=[
                go.Pie(labels=chart_data['x'], values=chart_data['y'])
            ])
        
        fig.update_layout(
            title=f"Chart of {numeric_columns[0]}",
            xaxis_title="Category",
            yaxis_title=numeric_columns[0]
        )
        
        # Display chart
        ui.plotly(fig)
    
    def _find_numeric_columns(self, columns: List[str], data: List[Tuple]) -> List[str]:
        """Find numeric columns in data"""
        numeric_columns = []
        
        for i, col in enumerate(columns):
            try:
                # Try to convert first few values to float
                for row in data[:5]:
                    float(row[i])
                numeric_columns.append(col)
            except (ValueError, TypeError):
                continue
        
        return numeric_columns
    
    def _prepare_chart_data(self, columns: List[str], data: List[Tuple], value_column: str) -> Dict[str, List]:
        """Prepare data for charting"""
        value_index = columns.index(value_column)
        
        # Group by first non-numeric column
        categories = []
        values = []
        
        for row in data:
            category = str(row[0])  # Use first column as category
            value = float(row[value_index])
            
            categories.append(category)
            values.append(value)
        
        return {'x': categories, 'y': values}
    
    def get_view_name(self) -> str:
        return "Simple Chart View"
    
    def can_handle_table(self, table_meta: Dict) -> bool:
        return True
    
    def get_priority(self) -> int:
        return 2
```

## Implementation Tasks

### Task 1: Create Plugin Development Documentation
- [ ] Create comprehensive plugin development guide
- [ ] Add code examples and best practices
- [ ] Create troubleshooting guide
- [ ] Add security guidelines

### Task 2: Implement Plugin Template Generator
- [ ] Create `tools/generate_plugin.py`
- [ ] Add template files for view and datasource plugins
- [ ] Implement template customization
- [ ] Add validation for generated plugins

### Task 3: Create Testing Utilities
- [ ] Create `tools/plugin_test_utils.py`
- [ ] Add base test classes for plugins
- [ ] Implement performance testing utilities
- [ ] Add security testing utilities

### Task 4: Provide Example Plugins
- [ ] Create simple chart view plugin example
- [ ] Create custom datasource plugin example
- [ ] Add comprehensive documentation for examples
- [ ] Include test cases for examples

### Task 5: Create Plugin Validation Tools
- [ ] Implement plugin validation system
- [ ] Add security validation tools
- [ ] Create performance validation tools
- [ ] Add integration testing tools

### Task 6: Add Development Tools
- [ ] Create plugin debugger
- [ ] Add plugin profiler
- [ ] Implement plugin packaging tools
- [ ] Add plugin installation tools

### Task 7: Testing
- [ ] Test template generator
- [ ] Test example plugins
- [ ] Test validation tools
- [ ] Test development tools

## Definition of Done
- [ ] Comprehensive plugin development documentation is created
- [ ] Plugin template generator is implemented
- [ ] Testing utilities for plugin development are created
- [ ] Example plugins demonstrating best practices are provided
- [ ] Plugin validation and testing tools are created
- [ ] Example plugins work correctly in the system
- [ ] Plugin development tools don't impact production functionality
- [ ] Documentation enables successful plugin development
- [ ] Tests cover plugin development kit functionality

## Risk Assessment
**Risk:** Complex development kit may confuse new developers
**Mitigation:** Clear documentation, simple examples, step-by-step guides

## Dependencies
- Story 1.2: Implement Plugin Manager with pluggy (must be completed first)

## Next Stories
- Story 6.1: Create User Documentation
- Story 6.2: Create Developer Documentation 