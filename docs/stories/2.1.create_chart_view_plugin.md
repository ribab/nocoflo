# Story 2.1: Create Chart View Plugin

## Epic Context
**Epic:** Epic 2: Plugin System Implementation  
**Epic Goal:** Implement extensible plugin system for views and datasources

## Story Details
**Priority:** High  
**Effort:** Large  
**Dependencies:** Story 1.2 (Implement Plugin Manager with pluggy)

## User Story
As a developer,
I want to implement chart view plugin using plotly or matplotlib,
so that users can visualize data in different ways beyond just tables.

## Acceptance Criteria
1. **TDD First**: Write comprehensive tests for chart view functionality before implementation
2. Implement chart view plugin using plotly or matplotlib
3. Create automatic view selection logic based on table characteristics
4. Chart view integrates seamlessly with existing navigation
5. Users can manually switch between table and chart views
6. Chart view supports common chart types (bar, line, pie, scatter)
7. **Test Coverage**: All chart functionality must have 90%+ test coverage

## Integration Verification
- Chart view works with existing table data
- View switching doesn't break existing functionality
- Chart view follows existing UI design patterns

## Technical Requirements

### Chart View Plugin Implementation
```python
# src/plugins/examples/chart_view_plugin.py
import pluggy
import plotly.graph_objects as go
import plotly.express as px
from typing import Dict, List, Any, Tuple
from components.views.base_view import BaseView
from components.datasources.base_datasource import BaseDatasource

hookimpl = pluggy.HookimplMarker("nocoflo")

class ChartViewPlugin:
    @hookimpl
    def get_view_class(self) -> Type[BaseView]:
        return ChartView
    
    @hookimpl
    def get_view_priority(self) -> int:
        return 2  # Higher priority than table view for suitable data
    
    @hookimpl
    def get_view_name(self) -> str:
        return "Chart View"
    
    @hookimpl
    def can_handle_table(self, table_meta: Dict) -> bool:
        return self._has_chartable_data(table_meta)

class ChartView(BaseView):
    def __init__(self, table_id: int, datasource: BaseDatasource):
        super().__init__(table_id, datasource)
        self.chart_type = 'auto'
        self.chart_config = {}
    
    def render(self) -> None:
        """Render the chart view"""
        # Get table data
        table_config = self._get_table_config()
        columns, data = self.datasource.get_table_data(table_config)
        
        # Determine best chart type
        chart_type = self._determine_chart_type(columns, data)
        
        # Create chart
        chart = self._create_chart(chart_type, columns, data)
        
        # Render chart controls and chart
        self._render_chart_interface(chart, chart_type)
    
    def get_view_name(self) -> str:
        return "Chart View"
    
    def can_handle_table(self, table_meta: Dict) -> bool:
        return self._has_chartable_data(table_meta)
    
    def get_priority(self) -> int:
        return 2
    
    def _has_chartable_data(self, table_meta: Dict) -> bool:
        """Check if table has data suitable for charting"""
        schema = self.datasource.get_schema(table_meta)
        numeric_columns = [col for col in schema if col.get('type') in ['INTEGER', 'REAL', 'NUMERIC']]
        return len(numeric_columns) > 0
    
    def _determine_chart_type(self, columns: List[str], data: List[Tuple]) -> str:
        """Automatically determine best chart type based on data"""
        if not data:
            return 'bar'
        
        # Analyze data structure
        numeric_cols = []
        categorical_cols = []
        
        for i, col in enumerate(columns):
            sample_values = [row[i] for row in data[:10] if row[i] is not None]
            if sample_values and all(isinstance(v, (int, float)) for v in sample_values):
                numeric_cols.append(col)
            else:
                categorical_cols.append(col)
        
        # Choose chart type based on data characteristics
        if len(numeric_cols) >= 2:
            return 'scatter'
        elif len(categorical_cols) >= 1 and len(numeric_cols) >= 1:
            return 'bar'
        elif len(numeric_cols) == 1:
            return 'histogram'
        else:
            return 'bar'
    
    def _create_chart(self, chart_type: str, columns: List[str], data: List[Tuple]) -> go.Figure:
        """Create plotly chart based on type and data"""
        if not data:
            return go.Figure()
        
        # Convert data to pandas-like structure
        df_data = []
        for row in data:
            df_data.append(dict(zip(columns, row)))
        
        if chart_type == 'bar':
            return self._create_bar_chart(columns, df_data)
        elif chart_type == 'line':
            return self._create_line_chart(columns, df_data)
        elif chart_type == 'scatter':
            return self._create_scatter_chart(columns, df_data)
        elif chart_type == 'pie':
            return self._create_pie_chart(columns, df_data)
        else:
            return self._create_bar_chart(columns, df_data)
    
    def _create_bar_chart(self, columns: List[str], data: List[Dict]) -> go.Figure:
        """Create bar chart"""
        numeric_cols = [col for col in columns if any(isinstance(row.get(col), (int, float)) for row in data)]
        categorical_cols = [col for col in columns if col not in numeric_cols]
        
        if not numeric_cols or not categorical_cols:
            return go.Figure()
        
        x_col = categorical_cols[0]
        y_col = numeric_cols[0]
        
        fig = go.Figure(data=[
            go.Bar(x=[row[x_col] for row in data], y=[row[y_col] for row in data])
        ])
        
        fig.update_layout(
            title=f"{y_col} by {x_col}",
            xaxis_title=x_col,
            yaxis_title=y_col,
            template="plotly_dark"
        )
        
        return fig
    
    def _create_scatter_chart(self, columns: List[str], data: List[Dict]) -> go.Figure:
        """Create scatter chart"""
        numeric_cols = [col for col in columns if any(isinstance(row.get(col), (int, float)) for row in data)]
        
        if len(numeric_cols) < 2:
            return go.Figure()
        
        x_col, y_col = numeric_cols[0], numeric_cols[1]
        
        fig = go.Figure(data=[
            go.Scatter(
                x=[row[x_col] for row in data if row.get(x_col) is not None],
                y=[row[y_col] for row in data if row.get(y_col) is not None],
                mode='markers'
            )
        ])
        
        fig.update_layout(
            title=f"{y_col} vs {x_col}",
            xaxis_title=x_col,
            yaxis_title=y_col,
            template="plotly_dark"
        )
        
        return fig
    
    def _render_chart_interface(self, chart: go.Figure, chart_type: str):
        """Render chart with controls"""
        from nicegui import ui
        
        # Chart type selector
        with ui.row().classes('w-full mb-4'):
            ui.label('Chart Type:').classes('mr-2')
            chart_types = ['auto', 'bar', 'line', 'scatter', 'pie', 'histogram']
            chart_select = ui.select(
                chart_types, 
                value=chart_type,
                on_change=lambda e: self._change_chart_type(e.value)
            )
        
        # Chart display
        ui.plotly(chart).classes('w-full h-96')
        
        # Chart controls
        with ui.row().classes('w-full mt-4'):
            ui.button('Export PNG', on_click=lambda: self._export_chart(chart, 'png'))
            ui.button('Export SVG', on_click=lambda: self._export_chart(chart, 'svg'))
            ui.button('Refresh Data', on_click=lambda: self.render())
    
    def _change_chart_type(self, new_type: str):
        """Change chart type and re-render"""
        self.chart_type = new_type
        self.render()
    
    def _export_chart(self, chart: go.Figure, format: str):
        """Export chart to file"""
        # Implementation for chart export
        pass
```

### View Selection Logic
```python
# src/components/views/view_selector.py
from typing import Dict, List
from components.views.base_view import BaseView

class ViewSelector:
    def __init__(self, plugin_manager):
        self.plugin_manager = plugin_manager
    
    def get_available_views(self, table_meta: Dict) -> List[BaseView]:
        """Get available views for a table"""
        available_views = []
        
        # Get all view plugins
        view_plugins = self.plugin_manager.get_view_plugins()
        
        for plugin in view_plugins:
            if plugin.can_handle_table(table_meta):
                view = plugin.get_view_class()(table_meta['id'], self.plugin_manager.get_datasource(table_meta['datasource_type']))
                available_views.append(view)
        
        # Sort by priority
        available_views.sort(key=lambda v: v.get_priority(), reverse=True)
        
        return available_views
    
    def get_default_view(self, table_meta: Dict) -> BaseView:
        """Get the default view for a table"""
        available_views = self.get_available_views(table_meta)
        return available_views[0] if available_views else None
```

## Implementation Tasks

### Task 1: Install Dependencies
- [ ] Add plotly to requirements.txt
- [ ] Install plotly dependency
- [ ] Test plotly integration

### Task 2: Create Chart View Plugin
- [ ] Create `src/plugins/examples/chart_view_plugin.py`
- [ ] Implement ChartViewPlugin class with hook implementations
- [ ] Implement ChartView class extending BaseView
- [ ] Add chart type detection logic

### Task 3: Implement Chart Types
- [ ] Implement bar chart creation
- [ ] Implement line chart creation
- [ ] Implement scatter chart creation
- [ ] Implement pie chart creation
- [ ] Implement histogram creation

### Task 4: Create View Selection Logic
- [ ] Create `src/components/views/view_selector.py`
- [ ] Implement automatic view selection
- [ ] Add view priority system
- [ ] Integrate with plugin manager

### Task 5: Integrate with UI
- [ ] Add chart view to table page
- [ ] Implement view switching controls
- [ ] Add chart export functionality
- [ ] Ensure responsive design

### Task 1: TDD - Write Tests First
- [ ] Create test suite for ChartView class with comprehensive test cases
- [ ] Write tests for chart type detection logic (_determine_chart_type)
- [ ] Create tests for chart creation methods (bar, line, scatter, pie)
- [ ] Write tests for data validation and error handling
- [ ] Create integration tests for chart view plugin registration
- [ ] Write UI tests for chart controls and view switching
- [ ] Create performance tests for large dataset chart rendering

### Task 6: Testing
- [ ] Test chart view with different data types
- [ ] Test automatic chart type selection
- [ ] Test view switching functionality
- [ ] Test chart export functionality
- [ ] Verify all tests pass with 90%+ coverage

## Definition of Done
- [ ] **TDD Complete**: All tests written before implementation and passing
- [ ] Chart view plugin is implemented with plotly
- [ ] Automatic view selection logic works correctly
- [ ] Chart view integrates with existing navigation
- [ ] Users can switch between table and chart views
- [ ] Chart view supports multiple chart types
- [ ] Chart view follows existing UI design patterns
- [ ] All existing functionality continues to work
- [ ] **Test Coverage**: 90%+ test coverage achieved
- [ ] **Test Quality**: All tests are meaningful and test actual functionality

## Risk Assessment
**Risk:** Chart rendering may be slow with large datasets
**Mitigation:** Implement data sampling and pagination for large datasets

## Dependencies
- Story 1.2: Implement Plugin Manager with pluggy (must be completed first)

## Next Stories
- Story 2.2: Create Form View Plugin
- Story 3.1: Create Plugin Management Interface 