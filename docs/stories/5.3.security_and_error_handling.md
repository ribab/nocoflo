# Story 5.3: Security and Error Handling

## Epic Context
**Epic:** Epic 5: Performance Optimization and Testing  
**Epic Goal:** Ensure the system meets performance requirements and maintains reliability

## Story Details
**Priority:** High  
**Effort:** Medium  
**Dependencies:** Story 1.2 (Implement Plugin Manager with pluggy)

## User Story
As a developer,
I want to implement comprehensive error handling and security validation for plugins,
so that the system remains stable and secure even when plugins fail or are malicious.

## Acceptance Criteria
1. Implement comprehensive error handling for plugins
2. Add security validation for plugin loading
3. Create graceful degradation when plugins fail
4. Implement proper logging for debugging
5. Add input validation and sanitization

## Integration Verification
- Plugin failures don't break core functionality
- Security measures prevent malicious plugins
- Error handling provides useful feedback to users

## Technical Requirements

### Security Validation System
```python
# src/components/security/plugin_validator.py
import hashlib
import json
import os
from typing import Dict, List, Any, Optional
from pathlib import Path
import ast
import logging

class PluginSecurityValidator:
    def __init__(self):
        self.allowed_imports = {
            'nicegui', 'ui', 'app',
            'typing', 'Dict', 'List', 'Any', 'Optional',
            'datetime', 'time',
            'json', 'pathlib', 'Path',
            'components.views.base_view',
            'components.datasources.base_datasource',
            'plugins.hookspecs',
        }
        
        self.forbidden_patterns = [
            'import os',
            'import subprocess',
            'import sys',
            'import socket',
            'import requests',
            'import urllib',
            'eval(',
            'exec(',
            '__import__(',
            'open(',
            'file(',
        ]
        
        self.max_file_size = 1024 * 1024  # 1MB
        self.max_plugin_size = 10 * 1024 * 1024  # 10MB
    
    def validate_plugin(self, plugin_path: str) -> Dict[str, Any]:
        """Validate plugin for security and safety"""
        validation_result = {
            'valid': True,
            'errors': [],
            'warnings': [],
            'security_score': 100,
        }
        
        try:
            # Check file size
            if not self._check_file_size(plugin_path):
                validation_result['valid'] = False
                validation_result['errors'].append('Plugin file too large')
                validation_result['security_score'] -= 20
            
            # Check file content
            content_validation = self._validate_file_content(plugin_path)
            validation_result['errors'].extend(content_validation['errors'])
            validation_result['warnings'].extend(content_validation['warnings'])
            validation_result['security_score'] -= content_validation['score_deduction']
            
            if content_validation['errors']:
                validation_result['valid'] = False
            
            # Check imports
            import_validation = self._validate_imports(plugin_path)
            validation_result['errors'].extend(import_validation['errors'])
            validation_result['warnings'].extend(import_validation['warnings'])
            validation_result['security_score'] -= import_validation['score_deduction']
            
            if import_validation['errors']:
                validation_result['valid'] = False
            
            # Check AST for dangerous patterns
            ast_validation = self._validate_ast(plugin_path)
            validation_result['errors'].extend(ast_validation['errors'])
            validation_result['warnings'].extend(ast_validation['warnings'])
            validation_result['security_score'] -= ast_validation['score_deduction']
            
            if ast_validation['errors']:
                validation_result['valid'] = False
            
            # Ensure minimum security score
            if validation_result['security_score'] < 70:
                validation_result['valid'] = False
                validation_result['errors'].append('Plugin failed security validation')
            
        except Exception as e:
            validation_result['valid'] = False
            validation_result['errors'].append(f'Validation error: {str(e)}')
            validation_result['security_score'] = 0
        
        return validation_result
    
    def _check_file_size(self, plugin_path: str) -> bool:
        """Check if plugin file size is within limits"""
        file_size = os.path.getsize(plugin_path)
        return file_size <= self.max_file_size
    
    def _validate_file_content(self, plugin_path: str) -> Dict[str, Any]:
        """Validate file content for dangerous patterns"""
        result = {'errors': [], 'warnings': [], 'score_deduction': 0}
        
        try:
            with open(plugin_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Check for forbidden patterns
            for pattern in self.forbidden_patterns:
                if pattern in content:
                    result['errors'].append(f'Forbidden pattern found: {pattern}')
                    result['score_deduction'] += 30
            
            # Check for suspicious patterns
            suspicious_patterns = [
                'subprocess',
                'os.system',
                'eval',
                'exec',
                '__import__',
            ]
            
            for pattern in suspicious_patterns:
                if pattern in content:
                    result['warnings'].append(f'Suspicious pattern found: {pattern}')
                    result['score_deduction'] += 10
            
        except Exception as e:
            result['errors'].append(f'Error reading file: {str(e)}')
            result['score_deduction'] += 50
        
        return result
    
    def _validate_imports(self, plugin_path: str) -> Dict[str, Any]:
        """Validate imports for security"""
        result = {'errors': [], 'warnings': [], 'score_deduction': 0}
        
        try:
            with open(plugin_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Parse imports
            tree = ast.parse(content)
            
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        if alias.name not in self.allowed_imports:
                            result['errors'].append(f'Forbidden import: {alias.name}')
                            result['score_deduction'] += 25
                
                elif isinstance(node, ast.ImportFrom):
                    if node.module not in self.allowed_imports:
                        result['errors'].append(f'Forbidden import: {node.module}')
                        result['score_deduction'] += 25
        
        except Exception as e:
            result['errors'].append(f'Error parsing imports: {str(e)}')
            result['score_deduction'] += 50
        
        return result
    
    def _validate_ast(self, plugin_path: str) -> Dict[str, Any]:
        """Validate AST for dangerous operations"""
        result = {'errors': [], 'warnings': [], 'score_deduction': 0}
        
        try:
            with open(plugin_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            tree = ast.parse(content)
            
            for node in ast.walk(tree):
                # Check for dangerous function calls
                if isinstance(node, ast.Call):
                    if isinstance(node.func, ast.Name):
                        if node.func.id in ['eval', 'exec', '__import__']:
                            result['errors'].append(f'Dangerous function call: {node.func.id}')
                            result['score_deduction'] += 50
                
                # Check for file operations
                elif isinstance(node, ast.Call):
                    if isinstance(node.func, ast.Name):
                        if node.func.id in ['open', 'file']:
                            result['warnings'].append(f'File operation: {node.func.id}')
                            result['score_deduction'] += 15
        
        except Exception as e:
            result['errors'].append(f'Error parsing AST: {str(e)}')
            result['score_deduction'] += 50
        
        return result
```

### Error Handling System
```python
# src/components/error_handling/plugin_error_handler.py
from typing import Dict, List, Any, Optional, Callable
import traceback
import logging
from datetime import datetime
from enum import Enum

class ErrorSeverity(Enum):
    LOW = 'low'
    MEDIUM = 'medium'
    HIGH = 'high'
    CRITICAL = 'critical'

class ErrorHandler:
    def __init__(self):
        self.error_callbacks: List[Callable] = []
        self.error_history: List[Dict] = []
        self.max_error_history = 1000
        self.error_thresholds = {
            ErrorSeverity.LOW: 100,
            ErrorSeverity.MEDIUM: 50,
            ErrorSeverity.HIGH: 10,
            ErrorSeverity.CRITICAL: 1,
        }
    
    def handle_plugin_error(self, plugin_name: str, error: Exception, context: Dict = None):
        """Handle plugin errors with graceful degradation"""
        error_info = {
            'timestamp': datetime.now(),
            'plugin_name': plugin_name,
            'error_type': type(error).__name__,
            'error_message': str(error),
            'traceback': traceback.format_exc(),
            'context': context or {},
            'severity': self._determine_severity(error),
        }
        
        # Log the error
        logging.error(f"Plugin error in {plugin_name}: {str(error)}")
        
        # Add to history
        self.error_history.append(error_info)
        
        # Trim history if too long
        if len(self.error_history) > self.max_error_history:
            self.error_history = self.error_history[-self.max_error_history:]
        
        # Check if we should disable the plugin
        if self._should_disable_plugin(plugin_name, error_info):
            self._disable_plugin(plugin_name, error_info)
        
        # Notify callbacks
        for callback in self.error_callbacks:
            try:
                callback(error_info)
            except Exception as e:
                logging.error(f"Error in error callback: {str(e)}")
        
        return error_info
    
    def _determine_severity(self, error: Exception) -> ErrorSeverity:
        """Determine error severity"""
        error_str = str(error).lower()
        
        if any(word in error_str for word in ['security', 'permission', 'access']):
            return ErrorSeverity.CRITICAL
        elif any(word in error_str for word in ['memory', 'timeout', 'connection']):
            return ErrorSeverity.HIGH
        elif any(word in error_str for word in ['validation', 'format']):
            return ErrorSeverity.MEDIUM
        else:
            return ErrorSeverity.LOW
    
    def _should_disable_plugin(self, plugin_name: str, error_info: Dict) -> bool:
        """Determine if plugin should be disabled"""
        recent_errors = [
            e for e in self.error_history[-100:]
            if e['plugin_name'] == plugin_name
        ]
        
        critical_errors = [e for e in recent_errors if e['severity'] == ErrorSeverity.CRITICAL]
        high_errors = [e for e in recent_errors if e['severity'] == ErrorSeverity.HIGH]
        
        # Disable if too many critical errors
        if len(critical_errors) >= self.error_thresholds[ErrorSeverity.CRITICAL]:
            return True
        
        # Disable if too many high severity errors
        if len(high_errors) >= self.error_thresholds[ErrorSeverity.HIGH]:
            return True
        
        return False
    
    def _disable_plugin(self, plugin_name: str, error_info: Dict):
        """Disable problematic plugin"""
        logging.warning(f"Disabling plugin {plugin_name} due to errors")
        
        # Implementation to disable plugin
        # This would typically update plugin configuration
        
        # Notify admin
        self._notify_admin_plugin_disabled(plugin_name, error_info)
    
    def _notify_admin_plugin_disabled(self, plugin_name: str, error_info: Dict):
        """Notify admin about disabled plugin"""
        # Implementation to notify admin
        # This could be via email, dashboard notification, etc.
        pass
    
    def add_error_callback(self, callback: Callable):
        """Add error callback"""
        self.error_callbacks.append(callback)
    
    def get_error_summary(self) -> Dict:
        """Get error summary"""
        if not self.error_history:
            return {}
        
        recent_errors = self.error_history[-100:]
        
        return {
            'total_errors': len(self.error_history),
            'recent_errors': len(recent_errors),
            'errors_by_severity': {
                severity.value: len([e for e in recent_errors if e['severity'] == severity])
                for severity in ErrorSeverity
            },
            'errors_by_plugin': {},
            'disabled_plugins': [],
        }
```

### Input Validation and Sanitization
```python
# src/components/security/input_validator.py
import re
from typing import Any, Dict, List, Optional
from dataclasses import dataclass

@dataclass
class ValidationRule:
    field_name: str
    required: bool = False
    min_length: Optional[int] = None
    max_length: Optional[int] = None
    pattern: Optional[str] = None
    allowed_values: Optional[List] = None
    custom_validator: Optional[callable] = None

class InputValidator:
    def __init__(self):
        self.validation_rules: Dict[str, List[ValidationRule]] = {}
        self.sanitization_rules: Dict[str, callable] = {}
        
        # Common validation patterns
        self.patterns = {
            'email': r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$',
            'url': r'^https?://[^\s/$.?#].[^\s]*$',
            'phone': r'^\+?[\d\s\-\(\)]+$',
            'date': r'^\d{4}-\d{2}-\d{2}$',
            'integer': r'^\d+$',
            'decimal': r'^\d+\.?\d*$',
        }
    
    def add_validation_rule(self, context: str, rule: ValidationRule):
        """Add validation rule for a context"""
        if context not in self.validation_rules:
            self.validation_rules[context] = []
        self.validation_rules[context].append(rule)
    
    def add_sanitization_rule(self, field_name: str, sanitizer: callable):
        """Add sanitization rule for a field"""
        self.sanitization_rules[field_name] = sanitizer
    
    def validate_input(self, context: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """Validate input data"""
        validation_result = {
            'valid': True,
            'errors': [],
            'sanitized_data': data.copy(),
        }
        
        if context not in self.validation_rules:
            return validation_result
        
        for rule in self.validation_rules[context]:
            field_value = data.get(rule.field_name)
            
            # Check if required
            if rule.required and (field_value is None or field_value == ''):
                validation_result['errors'].append(f'{rule.field_name} is required')
                validation_result['valid'] = False
                continue
            
            if field_value is not None and field_value != '':
                # Check length constraints
                if rule.min_length and len(str(field_value)) < rule.min_length:
                    validation_result['errors'].append(f'{rule.field_name} too short (min {rule.min_length})')
                    validation_result['valid'] = False
                
                if rule.max_length and len(str(field_value)) > rule.max_length:
                    validation_result['errors'].append(f'{rule.field_name} too long (max {rule.max_length})')
                    validation_result['valid'] = False
                
                # Check pattern
                if rule.pattern:
                    if not re.match(rule.pattern, str(field_value)):
                        validation_result['errors'].append(f'{rule.field_name} format invalid')
                        validation_result['valid'] = False
                
                # Check allowed values
                if rule.allowed_values and field_value not in rule.allowed_values:
                    validation_result['errors'].append(f'{rule.field_name} value not allowed')
                    validation_result['valid'] = False
                
                # Custom validation
                if rule.custom_validator:
                    try:
                        if not rule.custom_validator(field_value):
                            validation_result['errors'].append(f'{rule.field_name} validation failed')
                            validation_result['valid'] = False
                    except Exception as e:
                        validation_result['errors'].append(f'{rule.field_name} validation error: {str(e)}')
                        validation_result['valid'] = False
                
                # Sanitize if valid
                if validation_result['valid']:
                    sanitized_value = self._sanitize_field(rule.field_name, field_value)
                    validation_result['sanitized_data'][rule.field_name] = sanitized_value
        
        return validation_result
    
    def _sanitize_field(self, field_name: str, value: Any) -> Any:
        """Sanitize field value"""
        if field_name in self.sanitization_rules:
            return self.sanitization_rules[field_name](value)
        
        # Default sanitization
        if isinstance(value, str):
            # Remove potentially dangerous characters
            value = re.sub(r'[<>"\']', '', value)
            # Trim whitespace
            value = value.strip()
        
        return value
    
    def sanitize_html(self, html_content: str) -> str:
        """Sanitize HTML content"""
        # Remove script tags
        html_content = re.sub(r'<script[^>]*>.*?</script>', '', html_content, flags=re.IGNORECASE | re.DOTALL)
        
        # Remove dangerous attributes
        html_content = re.sub(r'\s*on\w+\s*=', '', html_content, flags=re.IGNORECASE)
        
        # Remove javascript: URLs
        html_content = re.sub(r'javascript:', '', html_content, flags=re.IGNORECASE)
        
        return html_content
    
    def sanitize_sql(self, sql_content: str) -> str:
        """Sanitize SQL content (basic)"""
        # Remove common SQL injection patterns
        dangerous_patterns = [
            r'--',
            r'/\*.*?\*/',
            r';\s*drop\s+table',
            r';\s*delete\s+from',
            r';\s*update\s+.*\s+set',
            r'union\s+select',
            r'exec\s*\(',
        ]
        
        for pattern in dangerous_patterns:
            sql_content = re.sub(pattern, '', sql_content, flags=re.IGNORECASE)
        
        return sql_content
```

### Graceful Degradation System
```python
# src/components/error_handling/graceful_degradation.py
from typing import Dict, List, Any, Optional, Callable
from enum import Enum

class DegradationLevel(Enum):
    NONE = 'none'
    PARTIAL = 'partial'
    LIMITED = 'limited'
    EMERGENCY = 'emergency'

class GracefulDegradation:
    def __init__(self):
        self.degradation_level = DegradationLevel.NONE
        self.fallback_handlers: Dict[str, Callable] = {}
        self.degradation_callbacks: List[Callable] = []
    
    def set_degradation_level(self, level: DegradationLevel):
        """Set degradation level"""
        self.degradation_level = level
        
        # Notify callbacks
        for callback in self.degradation_callbacks:
            try:
                callback(level)
            except Exception as e:
                logging.error(f"Error in degradation callback: {str(e)}")
    
    def add_fallback_handler(self, operation: str, handler: Callable):
        """Add fallback handler for operation"""
        self.fallback_handlers[operation] = handler
    
    def execute_with_fallback(self, operation: str, primary_func: Callable, *args, **kwargs):
        """Execute function with fallback"""
        try:
            return primary_func(*args, **kwargs)
        except Exception as e:
            logging.warning(f"Primary operation {operation} failed: {str(e)}")
            
            # Try fallback handler
            if operation in self.fallback_handlers:
                try:
                    return self.fallback_handlers[operation](*args, **kwargs)
                except Exception as fallback_error:
                    logging.error(f"Fallback for {operation} also failed: {str(fallback_error)}")
                    raise fallback_error
            else:
                raise e
    
    def get_degraded_functionality(self) -> Dict[str, Any]:
        """Get current degraded functionality"""
        return {
            'level': self.degradation_level.value,
            'available_operations': self._get_available_operations(),
            'disabled_operations': self._get_disabled_operations(),
        }
    
    def _get_available_operations(self) -> List[str]:
        """Get available operations based on degradation level"""
        if self.degradation_level == DegradationLevel.NONE:
            return ['all']
        elif self.degradation_level == DegradationLevel.PARTIAL:
            return ['read', 'basic_edit']
        elif self.degradation_level == DegradationLevel.LIMITED:
            return ['read']
        else:  # EMERGENCY
            return ['basic_view']
    
    def _get_disabled_operations(self) -> List[str]:
        """Get disabled operations based on degradation level"""
        if self.degradation_level == DegradationLevel.NONE:
            return []
        elif self.degradation_level == DegradationLevel.PARTIAL:
            return ['advanced_edit', 'plugins', 'export']
        elif self.degradation_level == DegradationLevel.LIMITED:
            return ['edit', 'plugins', 'export', 'import']
        else:  # EMERGENCY
            return ['edit', 'plugins', 'export', 'import', 'search', 'filter']
```

## Implementation Tasks

### Task 1: Create Security Validation System
- [ ] Create `src/components/security/plugin_validator.py`
- [ ] Implement plugin security validation
- [ ] Add import validation
- [ ] Create AST analysis for dangerous patterns

### Task 2: Implement Error Handling System
- [ ] Create `src/components/error_handling/plugin_error_handler.py`
- [ ] Add error severity classification
- [ ] Implement plugin disabling logic
- [ ] Create error history tracking

### Task 3: Add Input Validation
- [ ] Create `src/components/security/input_validator.py`
- [ ] Implement validation rules system
- [ ] Add sanitization functions
- [ ] Create HTML and SQL sanitization

### Task 4: Implement Graceful Degradation
- [ ] Create `src/components/error_handling/graceful_degradation.py`
- [ ] Add degradation levels
- [ ] Implement fallback handlers
- [ ] Create degradation callbacks

### Task 5: Integrate with Plugin System
- [ ] Add security validation to plugin loading
- [ ] Integrate error handling with plugin manager
- [ ] Add input validation to all user inputs
- [ ] Implement graceful degradation for plugin failures

### Task 6: Add Security Monitoring
- [ ] Create security event logging
- [ ] Add security alerts
- [ ] Implement security dashboard
- [ ] Add security reporting

### Task 7: Testing
- [ ] Test security validation
- [ ] Test error handling
- [ ] Test input validation
- [ ] Test graceful degradation

## Definition of Done
- [ ] Comprehensive error handling for plugins is implemented
- [ ] Security validation for plugin loading is added
- [ ] Graceful degradation when plugins fail is created
- [ ] Proper logging for debugging is implemented
- [ ] Input validation and sanitization is added
- [ ] Plugin failures don't break core functionality
- [ ] Security measures prevent malicious plugins
- [ ] Error handling provides useful feedback to users
- [ ] Tests cover security and error handling functionality

## Risk Assessment
**Risk:** Overly strict security may block legitimate plugins
**Mitigation:** Configurable security levels, whitelist system, admin override

## Dependencies
- Story 1.2: Implement Plugin Manager with pluggy (must be completed first)

## Next Stories
- Story 6.1: Create User Documentation
- Story 6.2: Create Developer Documentation 