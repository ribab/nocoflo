# Story 2.2: Create Form View Plugin

## Epic Context
**Epic:** Epic 2: Plugin System Implementation  
**Epic Goal:** Implement extensible plugin system for views and datasources

## Story Details
**Priority:** Medium  
**Effort:** Medium  
**Dependencies:** Story 1.2 (Implement Plugin Manager with pluggy)

## User Story
As a developer,
I want to implement form view plugin for single-record editing,
so that users can edit data in a more user-friendly format beyond just tables.

## Acceptance Criteria
1. **TDD First**: Write comprehensive tests for form view functionality before implementation
2. Implement form view plugin for single-record editing
3. Form view automatically generates based on table schema
4. Form view supports validation and error handling
5. Form view integrates with existing permission system
6. Users can switch between table, chart, and form views
7. **Test Coverage**: All form functionality must have 90%+ test coverage

## Integration Verification
- Form view works with existing table data and permissions
- Form validation prevents invalid data entry
- Form view follows existing UI design patterns

## Technical Requirements

### Form View Plugin Implementation
```python
# src/plugins/examples/form_view_plugin.py
import pluggy
from typing import Dict, List, Any, Optional
from components.views.base_view import BaseView
from components.datasources.base_datasource import BaseDatasource

hookimpl = pluggy.HookimplMarker("nocoflo")

class FormViewPlugin:
    @hookimpl
    def get_view_class(self) -> Type[BaseView]:
        return FormView
    
    @hookimpl
    def get_view_priority(self) -> int:
        return 3  # Lower priority than table and chart views
    
    @hookimpl
    def get_view_name(self) -> str:
        return "Form View"
    
    @hookimpl
    def can_handle_table(self, table_meta: Dict) -> bool:
        return self._is_suitable_for_form(table_meta)

class FormView(BaseView):
    def __init__(self, table_id: int, datasource: BaseDatasource):
        super().__init__(table_id, datasource)
        self.current_record = None
        self.form_fields = {}
        self.validation_rules = {}
    
    def render(self) -> None:
        """Render the form view"""
        from nicegui import ui
        
        # Get table schema and data
        table_config = self._get_table_config()
        schema = self.datasource.get_schema(table_config)
        
        # Get current record (first record or selected record)
        columns, data = self.datasource.get_table_data(table_config, limit=1)
        if data:
            self.current_record = dict(zip(columns, data[0]))
        else:
            self.current_record = {}
        
        # Render form interface
        self._render_form_interface(schema, self.current_record)
    
    def get_view_name(self) -> str:
        return "Form View"
    
    def can_handle_table(self, table_meta: Dict) -> bool:
        return self._is_suitable_for_form(table_meta)
    
    def get_priority(self) -> int:
        return 3
    
    def _is_suitable_for_form(self, table_meta: Dict) -> bool:
        """Determine if table is suitable for form view"""
        schema = self.datasource.get_schema(table_meta)
        
        # Good for tables with many columns or complex relationships
        column_count = len(schema)
        has_text_fields = any(col.get('type') in ['TEXT', 'VARCHAR'] for col in schema)
        
        return column_count > 5 or has_text_fields
    
    def _render_form_interface(self, schema: List[Dict], record: Dict):
        """Render form interface with fields"""
        from nicegui import ui
        
        # Form header
        with ui.card().classes('w-full mb-4'):
            ui.label('Record Details').classes('text-lg font-semibold mb-4')
            
            # Navigation controls
            with ui.row().classes('w-full justify-between mb-4'):
                ui.button('← Previous', on_click=lambda: self._navigate_record(-1))
                ui.button('Next →', on_click=lambda: self._navigate_record(1))
                ui.button('New Record', on_click=lambda: self._create_new_record())
        
        # Form fields
        with ui.card().classes('w-full'):
            with ui.column().classes('w-full gap-4'):
                for column in schema:
                    field_name = column['name']
                    field_type = column.get('type', 'TEXT')
                    field_value = record.get(field_name, '')
                    
                    # Create appropriate form field based on type
                    field = self._create_form_field(field_name, field_type, field_value, column)
                    self.form_fields[field_name] = field
                
                # Form actions
                with ui.row().classes('w-full justify-end gap-2 mt-6'):
                    ui.button('Cancel', on_click=lambda: self._cancel_edit())
                    ui.button('Save', on_click=lambda: self._save_record())
                    ui.button('Delete', on_click=lambda: self._delete_record(), color='red')
    
    def _create_form_field(self, field_name: str, field_type: str, field_value: Any, column: Dict):
        """Create appropriate form field based on column type"""
        from nicegui import ui
        
        # Field label
        ui.label(field_name.replace('_', ' ').title()).classes('text-sm font-medium text-gray-700')
        
        # Create field based on type
        if field_type in ['INTEGER', 'BIGINT']:
            return ui.number(
                value=field_value,
                placeholder=f'Enter {field_name}'
            ).classes('w-full px-3 py-2 border border-gray-300 rounded-md')
        
        elif field_type in ['REAL', 'DOUBLE', 'DECIMAL']:
            return ui.number(
                value=field_value,
                step=0.01,
                placeholder=f'Enter {field_name}'
            ).classes('w-full px-3 py-2 border border-gray-300 rounded-md')
        
        elif field_type == 'BOOLEAN':
            return ui.checkbox(
                text=field_name.replace('_', ' ').title(),
                value=bool(field_value)
            )
        
        elif field_type == 'DATE':
            return ui.date(
                value=field_value,
                placeholder=f'Select {field_name}'
            ).classes('w-full px-3 py-2 border border-gray-300 rounded-md')
        
        elif field_type == 'DATETIME':
            return ui.datetime(
                value=field_value,
                placeholder=f'Select {field_name}'
            ).classes('w-full px-3 py-2 border border-gray-300 rounded-md')
        
        else:  # TEXT, VARCHAR, etc.
            return ui.textarea(
                value=str(field_value) if field_value is not None else '',
                placeholder=f'Enter {field_name}',
                rows=3 if len(str(field_value or '')) > 100 else 1
            ).classes('w-full px-3 py-2 border border-gray-300 rounded-md')
    
    def _validate_form(self) -> List[str]:
        """Validate form data and return error messages"""
        errors = []
        
        for field_name, field in self.form_fields.items():
            value = field.value
            
            # Required field validation
            if self._is_required_field(field_name) and not value:
                errors.append(f"{field_name} is required")
            
            # Type validation
            if value and not self._validate_field_type(field_name, value):
                errors.append(f"{field_name} has invalid format")
        
        return errors
    
    def _is_required_field(self, field_name: str) -> bool:
        """Check if field is required"""
        # Implementation based on schema constraints
        return not field_name.endswith('_id') and field_name != 'id'
    
    def _validate_field_type(self, field_name: str, value: Any) -> bool:
        """Validate field value based on type"""
        # Basic type validation
        try:
            if isinstance(value, str) and value.strip() == '':
                return True  # Empty string is valid
            
            # Add more specific validation as needed
            return True
        except:
            return False
    
    def _save_record(self):
        """Save the current record"""
        from nicegui import ui
        
        # Validate form
        errors = self._validate_form()
        if errors:
            ui.notify(f'❌ Validation errors: {", ".join(errors)}', type='negative')
            return
        
        # Collect form data
        form_data = {}
        for field_name, field in self.form_fields.items():
            form_data[field_name] = field.value
        
        try:
            # Update or insert record
            if self.current_record.get('id'):
                # Update existing record
                success = self.datasource.update_cell(
                    self._get_table_config(),
                    'id',
                    str(self.current_record['id']),
                    'data',
                    form_data
                )
            else:
                # Insert new record
                success = self.datasource.insert_row(
                    self._get_table_config(),
                    form_data
                )
            
            if success:
                ui.notify('✅ Record saved successfully', type='positive')
                self._refresh_form()
            else:
                ui.notify('❌ Failed to save record', type='negative')
        
        except Exception as e:
            ui.notify(f'❌ Error saving record: {str(e)}', type='negative')
    
    def _delete_record(self):
        """Delete the current record"""
        from nicegui import ui
        
        if not self.current_record.get('id'):
            ui.notify('❌ No record to delete', type='negative')
            return
        
        try:
            success = self.datasource.delete_row(
                self._get_table_config(),
                'id',
                str(self.current_record['id'])
            )
            
            if success:
                ui.notify('✅ Record deleted successfully', type='positive')
                self._refresh_form()
            else:
                ui.notify('❌ Failed to delete record', type='negative')
        
        except Exception as e:
            ui.notify(f'❌ Error deleting record: {str(e)}', type='negative')
    
    def _navigate_record(self, direction: int):
        """Navigate to previous/next record"""
        # Implementation for record navigation
        pass
    
    def _create_new_record(self):
        """Create a new empty record"""
        self.current_record = {}
        self._refresh_form()
    
    def _cancel_edit(self):
        """Cancel current edit and refresh form"""
        self._refresh_form()
    
    def _refresh_form(self):
        """Refresh the form with current data"""
        self.render()
```

## Implementation Tasks

### Task 1: TDD - Write Tests First
- [ ] Create test suite for FormView class with comprehensive test cases
- [ ] Write tests for form field generation logic
- [ ] Create tests for form validation functionality
- [ ] Write tests for record navigation and CRUD operations
- [ ] Create integration tests for form view plugin registration
- [ ] Write UI tests for form controls and validation display
- [ ] Create performance tests for large schema form rendering

### Task 2: Create Form View Plugin
- [ ] Create `src/plugins/examples/form_view_plugin.py`
- [ ] Implement FormViewPlugin class with hook implementations
- [ ] Implement FormView class extending BaseView
- [ ] Add form field generation logic

### Task 2: Implement Form Field Types
- [ ] Implement text field rendering
- [ ] Implement number field rendering
- [ ] Implement boolean field rendering
- [ ] Implement date/datetime field rendering
- [ ] Implement textarea for long text

### Task 3: Add Form Validation
- [ ] Implement required field validation
- [ ] Implement type validation
- [ ] Implement custom validation rules
- [ ] Add validation error display

### Task 4: Implement Record Navigation
- [ ] Add previous/next record navigation
- [ ] Implement record creation
- [ ] Add record deletion
- [ ] Implement form refresh

### Task 5: Integrate with UI
- [ ] Add form view to table page
- [ ] Implement view switching controls
- [ ] Add form-specific styling
- [ ] Ensure responsive design

### Task 7: Testing
- [ ] Test form view with different data types
- [ ] Test form validation
- [ ] Test record navigation
- [ ] Test form submission
- [ ] Verify all tests pass with 90%+ coverage
- [ ] Run integration tests with real form scenarios

## Definition of Done
- [ ] **TDD Complete**: All tests written before implementation and passing
- [ ] Form view plugin is implemented
- [ ] Form view automatically generates based on table schema
- [ ] Form view supports validation and error handling
- [ ] Form view integrates with existing permission system
- [ ] Users can switch between table, chart, and form views
- [ ] Form view follows existing UI design patterns
- [ ] All existing functionality continues to work
- [ ] **Test Coverage**: 90%+ test coverage achieved
- [ ] **Test Quality**: All tests are meaningful and test actual functionality

## Risk Assessment
**Risk:** Form complexity may impact performance with large schemas
**Mitigation:** Lazy loading, pagination, and performance optimization

## Dependencies
- Story 1.2: Implement Plugin Manager with pluggy (must be completed first)

## Next Stories
- Story 2.3: Implement PostgreSQL Datasource Plugin
- Story 3.1: Create Plugin Management Interface 