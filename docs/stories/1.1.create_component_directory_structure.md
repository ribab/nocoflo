# Story 1.1: Create Component Directory Structure

## Epic Context
**Epic:** Epic 1: Component Architecture Foundation  
**Epic Goal:** Establish proper component separation and base interfaces to enable plugin development

## Story Details
**Priority:** Critical  
**Effort:** Medium  
**Dependencies:** None

## User Story
As a developer,
I want to establish the component directory structure and base interfaces,
so that we have a foundation for separating concerns and enabling plugin development.

## Acceptance Criteria
1. Component directories (layout/, views/, datasources/, common/) are created with proper structure
2. Base interfaces (BaseView, BaseDatasource, BaseLayout) are defined with clear contracts
3. Existing functionality is moved to default components without breaking changes
4. All existing tests continue to pass after component extraction

## Integration Verification
- All existing table viewing functionality works exactly as before
- Database operations continue to work with existing data
- UI navigation and layout remain unchanged from user perspective

## Technical Requirements

### Directory Structure
```
src/
├── components/
│   ├── __init__.py
│   ├── layout/
│   │   ├── __init__.py
│   │   ├── base_layout.py
│   │   ├── header.py
│   │   ├── left_drawer.py
│   │   └── right_drawer.py
│   ├── views/
│   │   ├── __init__.py
│   │   ├── base_view.py
│   │   └── table_view.py
│   ├── datasources/
│   │   ├── __init__.py
│   │   ├── base_datasource.py
│   │   └── sqlite_datasource.py
│   └── common/
│       ├── __init__.py
│       ├── auth.py
│       ├── permissions.py
│       └── audit.py
```

### Base Interfaces

#### BaseView Interface
```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any

class BaseView(ABC):
    def __init__(self, table_id: int, datasource: 'BaseDatasource'):
        self.table_id = table_id
        self.datasource = datasource
    
    @abstractmethod
    def render(self) -> None:
        """Render the view with data"""
        pass
    
    @abstractmethod
    def get_view_name(self) -> str:
        """Return human-readable view name"""
        pass
    
    @abstractmethod
    def can_handle_table(self, table_meta: Dict) -> bool:
        """Determine if view is appropriate for this table"""
        pass
    
    @abstractmethod
    def get_priority(self) -> int:
        """Return selection priority (higher = preferred)"""
        pass
```

#### BaseDatasource Interface
```python
from abc import ABC, abstractmethod
from typing import Dict, List, Tuple, Any

class BaseDatasource(ABC):
    @abstractmethod
    def get_table_data(self, table_config: Dict, limit: int = 100) -> Tuple[List[str], List[Tuple]]:
        """Retrieve data from source"""
        pass
    
    @abstractmethod
    def update_cell(self, table_config: Dict, pk_col: str, pk_value: str, column: str, new_value: Any) -> bool:
        """Update data in source"""
        pass
    
    @abstractmethod
    def insert_row(self, table_config: Dict, data: Dict) -> bool:
        """Insert new row into source"""
        pass
    
    @abstractmethod
    def delete_row(self, table_config: Dict, pk_col: str, pk_value: str) -> bool:
        """Delete row from source"""
        pass
    
    @abstractmethod
    def get_schema(self, table_config: Dict) -> List[Dict]:
        """Discover table structure"""
        pass
    
    @abstractmethod
    def test_connection(self, connection_config: Dict) -> bool:
        """Validate connection settings"""
        pass
```

#### BaseLayout Interface
```python
from abc import ABC, abstractmethod
from typing import Callable, Optional, Dict

class BaseLayout(ABC):
    def __init__(self, content_func: Callable, table_id: Optional[int] = None):
        self.content_func = content_func
        self.table_id = table_id
    
    @abstractmethod
    def render(self) -> None:
        """Render the complete layout"""
        pass
    
    @abstractmethod
    def get_user_tables(self) -> List[Dict]:
        """Get available tables for navigation"""
        pass
    
    @abstractmethod
    def show_table_menu(self, table: Dict) -> None:
        """Display table-specific menu"""
        pass
```

## Implementation Tasks

### Task 1: Create Directory Structure
- [ ] Create `src/components/` directory
- [ ] Create `src/components/layout/` subdirectory
- [ ] Create `src/components/views/` subdirectory
- [ ] Create `src/components/datasources/` subdirectory
- [ ] Create `src/components/common/` subdirectory
- [ ] Create `__init__.py` files in all directories

### Task 2: Define Base Interfaces
- [ ] Create `src/components/views/base_view.py` with BaseView interface
- [ ] Create `src/components/datasources/base_datasource.py` with BaseDatasource interface
- [ ] Create `src/components/layout/base_layout.py` with BaseLayout interface
- [ ] Add proper type hints and docstrings to all interfaces

### Task 3: Move Existing Code
- [ ] Move `src/layout_template.py` to `src/components/layout/base_layout.py`
- [ ] Extract table view logic from `src/pages/table_view.py` to `src/components/views/table_view.py`
- [ ] Extract authentication logic to `src/components/common/auth.py`
- [ ] Extract permission logic to `src/components/common/permissions.py`
- [ ] Extract audit logic to `src/components/common/audit.py`

### Task 4: Create Default Components
- [ ] Create `src/components/views/table_view.py` implementing BaseView
- [ ] Create `src/components/datasources/sqlite_datasource.py` implementing BaseDatasource
- [ ] Create `src/components/layout/header.py` for header component
- [ ] Create `src/components/layout/navigation.py` for navigation component

### Task 5: Update Imports and References
- [ ] Update all import statements in existing files
- [ ] Update page files to use new component structure
- [ ] Ensure all existing functionality continues to work

### Task 6: Testing
- [ ] Run existing tests to ensure no regressions
- [ ] Create basic tests for new component interfaces
- [ ] Verify all existing functionality works as before

## Definition of Done
- [ ] All component directories are created with proper structure
- [ ] Base interfaces are defined with clear contracts
- [ ] Existing functionality is moved to components without breaking changes
- [ ] All existing tests pass
- [ ] All existing functionality works exactly as before
- [ ] Code follows project coding standards
- [ ] Documentation is updated to reflect new structure

## Risk Assessment
**Risk:** Moving existing code may introduce bugs
**Mitigation:** Comprehensive testing after each move, gradual refactoring with rollback capability

## Dependencies
- None (this is the foundation story)

## Next Stories
- Story 1.2: Implement Plugin Manager with pluggy
- Story 1.3: Refactor Authentication and Layout Components 