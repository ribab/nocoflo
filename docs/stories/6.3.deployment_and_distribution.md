# Story 6.3: Deployment and Distribution

## Epic Context
**Epic:** Epic 6: Documentation and Deployment  
**Epic Goal:** Provide complete documentation and deployment capabilities

## Story Details
**Priority:** Low  
**Effort:** Medium  
**Dependencies:** Story 6.1 (Create User Documentation), Story 6.2 (Create Developer Documentation)

## User Story
As a system administrator,
I want automated deployment and distribution capabilities,
so that Nocoflo can be easily installed and maintained in production environments.

## Acceptance Criteria
1. Create Docker containerization
2. Implement automated deployment pipeline
3. Create installation scripts
4. Add configuration management
5. Create backup and restore procedures

## Integration Verification
- Deployment process is reliable and repeatable
- System can be easily installed and configured
- Backup and restore procedures work correctly

## Technical Requirements

### Docker Containerization
```dockerfile
# Dockerfile
FROM python:3.9-slim

# Set environment variables
ENV PYTHONUNBUFFERED=1
ENV PYTHONDONTWRITEBYTECODE=1
ENV NOCOFLO_ENV=production

# Set work directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    libpq-dev \
    default-libmysqlclient-dev \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY src/ ./src/
COPY docs/ ./docs/
COPY tools/ ./tools/

# Create necessary directories
RUN mkdir -p /app/data /app/logs /app/plugins

# Create non-root user
RUN useradd --create-home --shell /bin/bash nocoflo
RUN chown -R nocoflo:nocoflo /app
USER nocoflo

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# Start application
CMD ["python", "src/app.py", "--host", "0.0.0.0", "--port", "8080"]
```

### Docker Compose Configuration
```yaml
# docker-compose.yml
version: '3.8'

services:
  nocoflo:
    build: .
    ports:
      - "8080:8080"
    environment:
      - NOCOFLO_ENV=production
      - NOCOFLO_SECRET_KEY=${NOCOFLO_SECRET_KEY}
      - NOCOFLO_DATABASE_URL=${NOCOFLO_DATABASE_URL}
      - NOCOFLO_PLUGIN_DIR=/app/plugins
    volumes:
      - ./data:/app/data
      - ./logs:/app/logs
      - ./plugins:/app/plugins
      - ./config:/app/config
    depends_on:
      - postgres
    restart: unless-stopped
    networks:
      - nocoflo-network

  postgres:
    image: postgres:13
    environment:
      - POSTGRES_DB=nocoflo
      - POSTGRES_USER=nocoflo
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    networks:
      - nocoflo-network

  mysql:
    image: mysql:8.0
    environment:
      - MYSQL_DATABASE=nocoflo
      - MYSQL_USER=nocoflo
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
      - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}
    volumes:
      - mysql_data:/var/lib/mysql
    ports:
      - "3306:3306"
    networks:
      - nocoflo-network

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
    depends_on:
      - nocoflo
    networks:
      - nocoflo-network

volumes:
  postgres_data:
  mysql_data:

networks:
  nocoflo-network:
    driver: bridge
```

### Automated Deployment Pipeline
```yaml
# .github/workflows/deploy.yml
name: Deploy Nocoflo

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.9'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt
      
      - name: Run tests
        run: |
          python -m pytest tests/
      
      - name: Run linting
        run: |
          flake8 src/
          black --check src/
      
      - name: Security scan
        run: |
          bandit -r src/

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v2
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1
      
      - name: Login to Docker Hub
        uses: docker/login-action@v1
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v2
        with:
          context: .
          push: true
          tags: |
            your-org/nocoflo:latest
            your-org/nocoflo:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v2
      
      - name: Deploy to production
        uses: appleboy/ssh-action@v0.1.4
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.KEY }}
          script: |
            cd /opt/nocoflo
            docker-compose pull
            docker-compose up -d
            docker system prune -f
```

### Installation Scripts
```bash
#!/bin/bash
# install.sh

set -e

echo "Installing Nocoflo..."

# Check system requirements
check_requirements() {
    echo "Checking system requirements..."
    
    # Check Python version
    if ! command -v python3 &> /dev/null; then
        echo "Error: Python 3.9+ is required"
        exit 1
    fi
    
    # Check Docker
    if ! command -v docker &> /dev/null; then
        echo "Error: Docker is required"
        exit 1
    fi
    
    # Check Docker Compose
    if ! command -v docker-compose &> /dev/null; then
        echo "Error: Docker Compose is required"
        exit 1
    fi
}

# Create configuration
create_config() {
    echo "Creating configuration..."
    
    # Create .env file
    cat > .env << EOF
# Nocoflo Configuration
NOCOFLO_ENV=production
NOCOFLO_SECRET_KEY=$(openssl rand -hex 32)
NOCOFLO_DATABASE_URL=sqlite:///data/nocoflo.db

# PostgreSQL Configuration
POSTGRES_PASSWORD=$(openssl rand -base64 32)
POSTGRES_USER=nocoflo
POSTGRES_DB=nocoflo

# MySQL Configuration
MYSQL_PASSWORD=$(openssl rand -base64 32)
MYSQL_ROOT_PASSWORD=$(openssl rand -base64 32)
MYSQL_USER=nocoflo
MYSQL_DATABASE=nocoflo
EOF
    
    echo "Configuration created in .env file"
}

# Create directories
create_directories() {
    echo "Creating directories..."
    
    mkdir -p data logs plugins config
    mkdir -p nginx/ssl
    
    echo "Directories created"
}

# Setup Nginx
setup_nginx() {
    echo "Setting up Nginx..."
    
    # Create Nginx configuration
    cat > nginx/nginx.conf << EOF
events {
    worker_connections 1024;
}

http {
    upstream nocoflo {
        server nocoflo:8080;
    }
    
    server {
        listen 80;
        server_name localhost;
        
        location / {
            proxy_pass http://nocoflo;
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
        }
    }
}
EOF
    
    echo "Nginx configuration created"
}

# Start services
start_services() {
    echo "Starting services..."
    
    docker-compose up -d
    
    echo "Services started"
    echo "Nocoflo is available at http://localhost"
}

# Main installation
main() {
    check_requirements
    create_config
    create_directories
    setup_nginx
    start_services
    
    echo "Installation completed successfully!"
    echo "Access Nocoflo at: http://localhost"
    echo "Admin interface: http://localhost/admin"
}

main "$@"
```

### Configuration Management
```python
# src/config/deployment_config.py
import os
import json
from typing import Dict, Any, Optional
from pathlib import Path

class DeploymentConfig:
    def __init__(self, config_path: str = None):
        self.config_path = config_path or "config/deployment.json"
        self.config = self._load_config()
    
    def _load_config(self) -> Dict[str, Any]:
        """Load deployment configuration"""
        if os.path.exists(self.config_path):
            with open(self.config_path, 'r') as f:
                return json.load(f)
        return self._get_default_config()
    
    def _get_default_config(self) -> Dict[str, Any]:
        """Get default configuration"""
        return {
            'environment': os.environ.get('NOCOFLO_ENV', 'development'),
            'database': {
                'type': os.environ.get('NOCOFLO_DATABASE_TYPE', 'sqlite'),
                'url': os.environ.get('NOCOFLO_DATABASE_URL', 'sqlite:///nocoflo.db'),
                'pool_size': int(os.environ.get('NOCOFLO_DB_POOL_SIZE', '10')),
                'max_overflow': int(os.environ.get('NOCOFLO_DB_MAX_OVERFLOW', '20'))
            },
            'plugins': {
                'enabled': os.environ.get('NOCOFLO_PLUGINS_ENABLED', 'true').lower() == 'true',
                'directory': os.environ.get('NOCOFLO_PLUGIN_DIR', 'plugins'),
                'auto_reload': os.environ.get('NOCOFLO_PLUGIN_AUTO_RELOAD', 'false').lower() == 'true'
            },
            'security': {
                'secret_key': os.environ.get('NOCOFLO_SECRET_KEY', 'dev-secret-key'),
                'session_timeout': int(os.environ.get('NOCOFLO_SESSION_TIMEOUT', '3600')),
                'max_login_attempts': int(os.environ.get('NOCOFLO_MAX_LOGIN_ATTEMPTS', '5'))
            },
            'performance': {
                'cache_enabled': os.environ.get('NOCOFLO_CACHE_ENABLED', 'true').lower() == 'true',
                'cache_ttl': int(os.environ.get('NOCOFLO_CACHE_TTL', '300')),
                'max_memory_usage': int(os.environ.get('NOCOFLO_MAX_MEMORY_USAGE', '512'))
            },
            'logging': {
                'level': os.environ.get('NOCOFLO_LOG_LEVEL', 'INFO'),
                'file': os.environ.get('NOCOFLO_LOG_FILE', 'logs/nocoflo.log'),
                'max_size': int(os.environ.get('NOCOFLO_LOG_MAX_SIZE', '10')),
                'backup_count': int(os.environ.get('NOCOFLO_LOG_BACKUP_COUNT', '5'))
            }
        }
    
    def save_config(self):
        """Save configuration to file"""
        os.makedirs(os.path.dirname(self.config_path), exist_ok=True)
        with open(self.config_path, 'w') as f:
            json.dump(self.config, f, indent=2)
    
    def get(self, key: str, default: Any = None) -> Any:
        """Get configuration value"""
        keys = key.split('.')
        value = self.config
        
        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return default
        
        return value
    
    def set(self, key: str, value: Any):
        """Set configuration value"""
        keys = key.split('.')
        config = self.config
        
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        
        config[keys[-1]] = value
```

### Backup and Restore Procedures
```python
# tools/backup_restore.py
import os
import shutil
import sqlite3
import json
import tarfile
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any

class BackupManager:
    def __init__(self, backup_dir: str = "backups"):
        self.backup_dir = Path(backup_dir)
        self.backup_dir.mkdir(exist_ok=True)
    
    def create_backup(self, data_dir: str, config_dir: str) -> str:
        """Create a complete backup"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"nocoflo_backup_{timestamp}"
        backup_path = self.backup_dir / backup_name
        
        # Create backup directory
        backup_path.mkdir(exist_ok=True)
        
        try:
            # Backup data directory
            if os.path.exists(data_dir):
                shutil.copytree(data_dir, backup_path / "data")
            
            # Backup configuration
            if os.path.exists(config_dir):
                shutil.copytree(config_dir, backup_path / "config")
            
            # Backup database
            self._backup_database(backup_path)
            
            # Create backup manifest
            self._create_manifest(backup_path, timestamp)
            
            # Create compressed archive
            archive_path = self._create_archive(backup_path)
            
            # Clean up temporary files
            shutil.rmtree(backup_path)
            
            print(f"Backup created: {archive_path}")
            return str(archive_path)
            
        except Exception as e:
            print(f"Backup failed: {str(e)}")
            if backup_path.exists():
                shutil.rmtree(backup_path)
            raise
    
    def restore_backup(self, backup_file: str, target_dir: str):
        """Restore from backup"""
        backup_path = Path(backup_file)
        
        if not backup_path.exists():
            raise FileNotFoundError(f"Backup file not found: {backup_file}")
        
        # Extract backup
        extract_dir = self.backup_dir / "temp_restore"
        extract_dir.mkdir(exist_ok=True)
        
        try:
            with tarfile.open(backup_file, 'r:gz') as tar:
                tar.extractall(extract_dir)
            
            # Find backup directory
            backup_dirs = list(extract_dir.glob("nocoflo_backup_*"))
            if not backup_dirs:
                raise ValueError("Invalid backup format")
            
            backup_dir = backup_dirs[0]
            
            # Restore data
            data_source = backup_dir / "data"
            if data_source.exists():
                shutil.rmtree(target_dir, ignore_errors=True)
                shutil.copytree(data_source, target_dir)
            
            # Restore configuration
            config_source = backup_dir / "config"
            if config_source.exists():
                config_target = Path(target_dir).parent / "config"
                shutil.rmtree(config_target, ignore_errors=True)
                shutil.copytree(config_source, config_target)
            
            # Restore database
            self._restore_database(backup_dir)
            
            print("Backup restored successfully")
            
        finally:
            # Clean up
            if extract_dir.exists():
                shutil.rmtree(extract_dir)
    
    def _backup_database(self, backup_path: Path):
        """Backup SQLite database"""
        db_path = "data/nocoflo.db"
        if os.path.exists(db_path):
            shutil.copy2(db_path, backup_path / "nocoflo.db")
    
    def _restore_database(self, backup_path: Path):
        """Restore SQLite database"""
        db_backup = backup_path / "nocoflo.db"
        if db_backup.exists():
            shutil.copy2(db_backup, "data/nocoflo.db")
    
    def _create_manifest(self, backup_path: Path, timestamp: str):
        """Create backup manifest"""
        manifest = {
            'timestamp': timestamp,
            'version': '1.0',
            'components': [
                'data',
                'config',
                'database'
            ],
            'created_by': 'Nocoflo Backup Manager'
        }
        
        with open(backup_path / "manifest.json", 'w') as f:
            json.dump(manifest, f, indent=2)
    
    def _create_archive(self, backup_path: Path) -> str:
        """Create compressed archive"""
        archive_name = f"{backup_path.name}.tar.gz"
        archive_path = self.backup_dir / archive_name
        
        with tarfile.open(archive_path, 'w:gz') as tar:
            tar.add(backup_path, arcname=backup_path.name)
        
        return str(archive_path)
    
    def list_backups(self) -> List[Dict[str, Any]]:
        """List available backups"""
        backups = []
        
        for backup_file in self.backup_dir.glob("*.tar.gz"):
            try:
                # Extract manifest to get metadata
                with tarfile.open(backup_file, 'r:gz') as tar:
                    manifest_member = None
                    for member in tar.getmembers():
                        if member.name.endswith('manifest.json'):
                            manifest_member = member
                            break
                    
                    if manifest_member:
                        manifest_content = tar.extractfile(manifest_member).read()
                        manifest = json.loads(manifest_content)
                        
                        backups.append({
                            'file': backup_file.name,
                            'timestamp': manifest['timestamp'],
                            'version': manifest['version'],
                            'size': backup_file.stat().st_size
                        })
            except Exception as e:
                print(f"Error reading backup {backup_file}: {str(e)}")
        
        return sorted(backups, key=lambda x: x['timestamp'], reverse=True)

def main():
    import argparse
    
    parser = argparse.ArgumentParser(description='Nocoflo Backup Manager')
    parser.add_argument('action', choices=['backup', 'restore', 'list'])
    parser.add_argument('--backup-file', help='Backup file for restore')
    parser.add_argument('--data-dir', default='data', help='Data directory')
    parser.add_argument('--config-dir', default='config', help='Config directory')
    
    args = parser.parse_args()
    
    backup_manager = BackupManager()
    
    if args.action == 'backup':
        backup_manager.create_backup(args.data_dir, args.config_dir)
    elif args.action == 'restore':
        if not args.backup_file:
            print("Error: --backup-file is required for restore")
            exit(1)
        backup_manager.restore_backup(args.backup_file, args.data_dir)
    elif args.action == 'list':
        backups = backup_manager.list_backups()
        for backup in backups:
            print(f"{backup['file']} - {backup['timestamp']} - {backup['size']} bytes")

if __name__ == '__main__':
    main()
```

## Implementation Tasks

### Task 1: Create Docker Containerization
- [ ] Create Dockerfile for production deployment
- [ ] Add Docker Compose configuration
- [ ] Create multi-stage build for optimization
- [ ] Add health checks and monitoring

### Task 2: Implement Automated Deployment Pipeline
- [ ] Create GitHub Actions workflow
- [ ] Add automated testing in pipeline
- [ ] Implement staging deployment
- [ ] Add production deployment automation

### Task 3: Create Installation Scripts
- [ ] Create install.sh script
- [ ] Add uninstall.sh script
- [ ] Create update.sh script
- [ ] Add system requirement checks

### Task 4: Add Configuration Management
- [ ] Create deployment configuration system
- [ ] Add environment variable management
- [ ] Implement configuration validation
- [ ] Add configuration migration tools

### Task 5: Create Backup and Restore Procedures
- [ ] Implement backup manager
- [ ] Add database backup procedures
- [ ] Create configuration backup
- [ ] Add restore procedures

### Task 6: Add Monitoring and Logging
- [ ] Implement application monitoring
- [ ] Add log aggregation
- [ ] Create alerting system
- [ ] Add performance monitoring

### Task 7: Create Documentation
- [ ] Document deployment procedures
- [ ] Add troubleshooting guide
- [ ] Create maintenance procedures
- [ ] Add disaster recovery guide

## Definition of Done
- [ ] Docker containerization is created
- [ ] Automated deployment pipeline is implemented
- [ ] Installation scripts are created
- [ ] Configuration management is added
- [ ] Backup and restore procedures are created
- [ ] Deployment process is reliable and repeatable
- [ ] System can be easily installed and configured
- [ ] Backup and restore procedures work correctly
- [ ] Tests cover deployment functionality

## Risk Assessment
**Risk:** Deployment complexity may cause issues
**Mitigation:** Comprehensive testing, rollback procedures, monitoring

## Dependencies
- Story 6.1: Create User Documentation (for deployment documentation)
- Story 6.2: Create Developer Documentation (for deployment procedures)

## Next Stories
- None - This completes all stories in the epic! 