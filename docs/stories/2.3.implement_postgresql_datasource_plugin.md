# Story 2.3: Implement PostgreSQL Datasource Plugin

## Epic Context
**Epic:** Epic 2: Plugin System Implementation  
**Epic Goal:** Implement extensible plugin system for views and datasources

## Story Details
**Priority:** Medium  
**Effort:** Large  
**Dependencies:** Story 1.2 (Implement Plugin Manager with pluggy)

## User Story
As a developer,
I want to implement a PostgreSQL datasource plugin with connection management,
so that users can connect to PostgreSQL databases while maintaining SQLite as the default.

## Acceptance Criteria
1. **TDD First**: Write comprehensive tests for PostgreSQL datasource functionality before implementation
2. Create PostgreSQL datasource plugin with connection management
3. Implement connection testing and validation
4. Create datasource configuration interface
5. PostgreSQL plugin integrates with existing metadata system
6. Support for PostgreSQL-specific features (schemas, etc.)
7. **Test Coverage**: All PostgreSQL functionality must have 90%+ test coverage

## Integration Verification
- PostgreSQL datasource works with existing view plugins
- Connection management is robust and handles errors gracefully
- Configuration interface is user-friendly and secure

## Technical Requirements

### PostgreSQL Datasource Plugin
```python
# src/plugins/examples/postgresql_datasource_plugin.py
import pluggy
import psycopg2
import psycopg2.extras
from typing import Dict, List, Any, Type, Tuple, Optional
from components.datasources.base_datasource import BaseDatasource
import logging
from urllib.parse import urlparse

hookimpl = pluggy.HookimplMarker("nocoflo")

class PostgreSQLDatasourcePlugin:
    @hookimpl
    def get_datasource_class(self) -> Type[BaseDatasource]:
        return PostgreSQLDatasource
    
    @hookimpl
    def get_supported_schemes(self) -> List[str]:
        return ["postgresql", "postgres"]
    
    @hookimpl
    def get_datasource_name(self) -> str:
        return "PostgreSQL Datasource"
    
    @hookimpl
    def get_datasource_description(self) -> str:
        return "Connect to PostgreSQL databases with full schema support"

class PostgreSQLDatasource(BaseDatasource):
    def __init__(self, connection_config: Dict[str, Any]):
        super().__init__(connection_config)
        self.connection = None
        self.cursor = None
        self.connection_string = self._build_connection_string(connection_config)
        self.schema = connection_config.get('schema', 'public')
        self.ssl_mode = connection_config.get('ssl_mode', 'prefer')
        
    def _build_connection_string(self, config: Dict[str, Any]) -> str:
        """Build PostgreSQL connection string"""
        host = config.get('host', 'localhost')
        port = config.get('port', 5432)
        database = config.get('database', '')
        username = config.get('username', '')
        password = config.get('password', '')
        
        # Build connection string
        conn_str = f"postgresql://{username}:{password}@{host}:{port}/{database}"
        
        # Add SSL mode if specified
        if self.ssl_mode != 'prefer':
            conn_str += f"?sslmode={self.ssl_mode}"
        
        return conn_str
    
    def connect(self) -> bool:
        """Establish connection to PostgreSQL database"""
        try:
            self.connection = psycopg2.connect(
                self.connection_string,
                cursor_factory=psycopg2.extras.RealDictCursor
            )
            self.cursor = self.connection.cursor()
            
            # Test connection
            self.cursor.execute("SELECT version()")
            version = self.cursor.fetchone()
            logging.info(f"Connected to PostgreSQL: {version['version']}")
            
            return True
            
        except Exception as e:
            logging.error(f"PostgreSQL connection failed: {str(e)}")
            return False
    
    def disconnect(self):
        """Close PostgreSQL connection"""
        if self.cursor:
            self.cursor.close()
        if self.connection:
            self.connection.close()
    
    def test_connection(self, connection_config: Dict[str, Any]) -> bool:
        """Test PostgreSQL connection"""
        try:
            # Create temporary connection for testing
            test_conn = psycopg2.connect(
                self._build_connection_string(connection_config)
            )
            test_cursor = test_conn.cursor()
            test_cursor.execute("SELECT 1")
            test_cursor.fetchone()
            test_cursor.close()
            test_conn.close()
            return True
        except Exception as e:
            logging.error(f"PostgreSQL connection test failed: {str(e)}")
            return False
    
    def get_table_data(self, table_config: Dict[str, Any], limit: int = 100) -> Tuple[List[str], List[Tuple]]:
        """Retrieve data from PostgreSQL table"""
        if not self.connection:
            if not self.connect():
                raise Exception("Failed to connect to PostgreSQL")
        
        try:
            table_name = table_config.get('table_name')
            schema_name = table_config.get('schema', self.schema)
            
            # Get column information
            columns_query = """
                SELECT column_name, data_type, is_nullable
                FROM information_schema.columns
                WHERE table_schema = %s AND table_name = %s
                ORDER BY ordinal_position
            """
            self.cursor.execute(columns_query, (schema_name, table_name))
            columns_info = self.cursor.fetchall()
            
            # Extract column names
            columns = [col['column_name'] for col in columns_info]
            
            # Get data with limit
            data_query = f"""
                SELECT * FROM {schema_name}.{table_name}
                LIMIT %s
            """
            self.cursor.execute(data_query, (limit,))
            data = self.cursor.fetchall()
            
            # Convert to tuples
            data_tuples = [tuple(row.values()) for row in data]
            
            return columns, data_tuples
            
        except Exception as e:
            logging.error(f"Error retrieving PostgreSQL data: {str(e)}")
            raise
    
    def update_cell(self, table_config: Dict[str, Any], pk_col: str, pk_value: str, column: str, new_value: Any) -> bool:
        """Update cell value in PostgreSQL table"""
        if not self.connection:
            if not self.connect():
                return False
        
        try:
            table_name = table_config.get('table_name')
            schema_name = table_config.get('schema', self.schema)
            
            # Build update query
            update_query = f"""
                UPDATE {schema_name}.{table_name}
                SET {column} = %s
                WHERE {pk_col} = %s
            """
            
            self.cursor.execute(update_query, (new_value, pk_value))
            self.connection.commit()
            
            return self.cursor.rowcount > 0
            
        except Exception as e:
            logging.error(f"Error updating PostgreSQL cell: {str(e)}")
            self.connection.rollback()
            return False
    
    def insert_row(self, table_config: Dict[str, Any], data: Dict[str, Any]) -> bool:
        """Insert new row into PostgreSQL table"""
        if not self.connection:
            if not self.connect():
                return False
        
        try:
            table_name = table_config.get('table_name')
            schema_name = table_config.get('schema', self.schema)
            
            # Build insert query
            columns = list(data.keys())
            values = list(data.values())
            placeholders = ', '.join(['%s'] * len(columns))
            
            insert_query = f"""
                INSERT INTO {schema_name}.{table_name} ({', '.join(columns)})
                VALUES ({placeholders})
            """
            
            self.cursor.execute(insert_query, values)
            self.connection.commit()
            
            return True
            
        except Exception as e:
            logging.error(f"Error inserting PostgreSQL row: {str(e)}")
            self.connection.rollback()
            return False
    
    def delete_row(self, table_config: Dict[str, Any], pk_col: str, pk_value: str) -> bool:
        """Delete row from PostgreSQL table"""
        if not self.connection:
            if not self.connect():
                return False
        
        try:
            table_name = table_config.get('table_name')
            schema_name = table_config.get('schema', self.schema)
            
            # Build delete query
            delete_query = f"""
                DELETE FROM {schema_name}.{table_name}
                WHERE {pk_col} = %s
            """
            
            self.cursor.execute(delete_query, (pk_value,))
            self.connection.commit()
            
            return self.cursor.rowcount > 0
            
        except Exception as e:
            logging.error(f"Error deleting PostgreSQL row: {str(e)}")
            self.connection.rollback()
            return False
    
    def get_schema(self, table_config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Get table schema from PostgreSQL"""
        if not self.connection:
            if not self.connect():
                return []
        
        try:
            table_name = table_config.get('table_name')
            schema_name = table_config.get('schema', self.schema)
            
            # Get detailed column information
            schema_query = """
                SELECT 
                    column_name,
                    data_type,
                    is_nullable,
                    column_default,
                    character_maximum_length,
                    numeric_precision,
                    numeric_scale
                FROM information_schema.columns
                WHERE table_schema = %s AND table_name = %s
                ORDER BY ordinal_position
            """
            
            self.cursor.execute(schema_query, (schema_name, table_name))
            columns_info = self.cursor.fetchall()
            
            schema = []
            for col in columns_info:
                schema.append({
                    'name': col['column_name'],
                    'type': col['data_type'],
                    'nullable': col['is_nullable'] == 'YES',
                    'default': col['column_default'],
                    'max_length': col['character_maximum_length'],
                    'precision': col['numeric_precision'],
                    'scale': col['numeric_scale']
                })
            
            return schema
            
        except Exception as e:
            logging.error(f"Error getting PostgreSQL schema: {str(e)}")
            return []
    
    def get_available_tables(self) -> List[Dict[str, Any]]:
        """Get list of available tables in PostgreSQL"""
        if not self.connection:
            if not self.connect():
                return []
        
        try:
            # Get tables from current schema
            tables_query = """
                SELECT 
                    table_name,
                    table_type
                FROM information_schema.tables
                WHERE table_schema = %s
                ORDER BY table_name
            """
            
            self.cursor.execute(tables_query, (self.schema,))
            tables = self.cursor.fetchall()
            
            available_tables = []
            for table in tables:
                if table['table_type'] == 'BASE TABLE':
                    # Get row count
                    count_query = f"SELECT COUNT(*) FROM {self.schema}.{table['table_name']}"
                    self.cursor.execute(count_query)
                    row_count = self.cursor.fetchone()['count']
                    
                    available_tables.append({
                        'name': table['table_name'],
                        'schema': self.schema,
                        'row_count': row_count,
                        'type': 'table'
                    })
            
            return available_tables
            
        except Exception as e:
            logging.error(f"Error getting PostgreSQL tables: {str(e)}")
            return []
    
    def get_available_schemas(self) -> List[str]:
        """Get list of available schemas in PostgreSQL"""
        if not self.connection:
            if not self.connect():
                return []
        
        try:
            schemas_query = """
                SELECT schema_name
                FROM information_schema.schemata
                WHERE schema_name NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
                ORDER BY schema_name
            """
            
            self.cursor.execute(schemas_query)
            schemas = self.cursor.fetchall()
            
            return [schema['schema_name'] for schema in schemas]
            
        except Exception as e:
            logging.error(f"Error getting PostgreSQL schemas: {str(e)}")
            return []
    
    def execute_custom_query(self, query: str, parameters: Tuple = None) -> Tuple[List[str], List[Tuple]]:
        """Execute custom SQL query"""
        if not self.connection:
            if not self.connect():
                raise Exception("Failed to connect to PostgreSQL")
        
        try:
            self.cursor.execute(query, parameters or ())
            
            if self.cursor.description:
                # SELECT query
                columns = [desc[0] for desc in self.cursor.description]
                data = [tuple(row.values()) for row in self.cursor.fetchall()]
                return columns, data
            else:
                # INSERT/UPDATE/DELETE query
                self.connection.commit()
                return [], []
                
        except Exception as e:
            logging.error(f"Error executing custom PostgreSQL query: {str(e)}")
            self.connection.rollback()
            raise
```

### PostgreSQL Configuration Interface
```python
# src/pages/admin/postgresql_configuration.py
from nicegui import ui, app
from typing import Dict, List, Any, Optional
from components.common.auth import AuthManager
from components.datasources.base_datasource import BaseDatasource

@ui.page('/admin/postgresql')
def postgresql_configuration():
    """PostgreSQL configuration interface"""
    auth = AuthManager()
    
    # Require admin authentication
    if not auth.require_auth('/login') or not auth.is_admin():
        ui.navigate.to('/login')
        return
    
    # Header
    with ui.header().classes('bg-primary text-white'):
        ui.label('PostgreSQL Configuration').classes('text-xl font-bold')
    
    # Main content
    with ui.column().classes('w-full p-6'):
        # Connection configuration
        with ui.card().classes('w-full mb-6'):
            ui.label('Connection Settings').classes('text-lg font-semibold mb-4')
            
            with ui.column().classes('w-full gap-4'):
                # Host and port
                with ui.row().classes('w-full gap-4'):
                    host_input = ui.input('Host', value='localhost').classes('flex-1')
                    port_input = ui.input('Port', value='5432').classes('flex-1')
                
                # Database and credentials
                with ui.row().classes('w-full gap-4'):
                    database_input = ui.input('Database').classes('flex-1')
                    username_input = ui.input('Username').classes('flex-1')
                    password_input = ui.input('Password', password=True).classes('flex-1')
                
                # Schema and SSL
                with ui.row().classes('w-full gap-4'):
                    schema_input = ui.input('Schema', value='public').classes('flex-1')
                    ssl_select = ui.select('SSL Mode', options=['prefer', 'require', 'verify-ca', 'verify-full']).classes('flex-1')
                
                # Test connection button
                test_button = ui.button('Test Connection', on_click=lambda: test_connection())
        
        # Connection status
        with ui.card().classes('w-full mb-6'):
            ui.label('Connection Status').classes('text-lg font-semibold mb-4')
            
            status_container = ui.column().classes('w-full')
        
        # Available tables
        with ui.card().classes('w-full mb-6'):
            ui.label('Available Tables').classes('text-lg font-semibold mb-4')
            
            tables_container = ui.column().classes('w-full')
        
        # Available schemas
        with ui.card().classes('w-full mb-6'):
            ui.label('Available Schemas').classes('text-lg font-semibold mb-4')
            
            schemas_container = ui.column().classes('w-full')
    
    def test_connection():
        """Test PostgreSQL connection"""
        try:
            # Build connection config
            config = {
                'host': host_input.value,
                'port': int(port_input.value),
                'database': database_input.value,
                'username': username_input.value,
                'password': password_input.value,
                'schema': schema_input.value,
                'ssl_mode': ssl_select.value
            }
            
            # Test connection
            from plugins.examples.postgresql_datasource_plugin import PostgreSQLDatasource
            datasource = PostgreSQLDatasource(config)
            
            if datasource.test_connection(config):
                ui.notify('✅ Connection successful!', type='positive')
                load_connection_info()
            else:
                ui.notify('❌ Connection failed', type='negative')
                
        except Exception as e:
            ui.notify(f'❌ Connection error: {str(e)}', type='negative')
    
    def load_connection_info():
        """Load connection information after successful connection"""
        try:
            # Build connection config
            config = {
                'host': host_input.value,
                'port': int(port_input.value),
                'database': database_input.value,
                'username': username_input.value,
                'password': password_input.value,
                'schema': schema_input.value,
                'ssl_mode': ssl_select.value
            }
            
            # Create datasource
            from plugins.examples.postgresql_datasource_plugin import PostgreSQLDatasource
            datasource = PostgreSQLDatasource(config)
            
            if datasource.connect():
                # Update status
                status_container.clear()
                with status_container:
                    ui.label('✅ Connected').classes('text-green-600 font-semibold')
                    ui.label(f"Host: {config['host']}:{config['port']}")
                    ui.label(f"Database: {config['database']}")
                    ui.label(f"Schema: {config['schema']}")
                
                # Load tables
                tables_container.clear()
                tables = datasource.get_available_tables()
                with tables_container:
                    if tables:
                        with ui.table().classes('w-full'):
                            ui.table_column('Table Name', 'name')
                            ui.table_column('Schema', 'schema')
                            ui.table_column('Row Count', 'row_count')
                            
                            for table in tables:
                                with ui.table_row():
                                    ui.table_cell(table['name'])
                                    ui.table_cell(table['schema'])
                                    ui.table_cell(str(table['row_count']))
                    else:
                        ui.label('No tables found')
                
                # Load schemas
                schemas_container.clear()
                schemas = datasource.get_available_schemas()
                with schemas_container:
                    if schemas:
                        for schema in schemas:
                            ui.label(f"• {schema}")
                    else:
                        ui.label('No schemas found')
                
                datasource.disconnect()
                
        except Exception as e:
            ui.notify(f'❌ Error loading connection info: {str(e)}', type='negative')
```

## Implementation Tasks

### Task 1: TDD - Write Tests First
- [ ] Create test suite for PostgreSQLDatasource class with comprehensive test cases
- [ ] Write tests for connection management and string building
- [ ] Create tests for data retrieval and manipulation methods
- [ ] Write tests for schema discovery and table operations
- [ ] Create integration tests for PostgreSQL plugin registration
- [ ] Write tests for connection error handling and recovery
- [ ] Create performance tests for large dataset operations

### Task 2: Create PostgreSQL Datasource Plugin
- [ ] Create `src/plugins/examples/postgresql_datasource_plugin.py`
- [ ] Implement PostgreSQL connection management
- [ ] Add connection testing and validation
- [ ] Implement data retrieval and manipulation methods

### Task 2: Add PostgreSQL Configuration Interface
- [ ] Create `src/pages/admin/postgresql_configuration.py`
- [ ] Implement connection configuration form
- [ ] Add connection testing functionality
- [ ] Create table and schema discovery

### Task 3: Integrate with Plugin System
- [ ] Register PostgreSQL plugin with plugin manager
- [ ] Add PostgreSQL support to datasource selection
- [ ] Implement plugin configuration storage
- [ ] Add plugin validation for PostgreSQL

### Task 4: Add PostgreSQL-Specific Features
- [ ] Implement schema support
- [ ] Add SSL configuration
- [ ] Support for custom queries
- [ ] Add connection pooling

### Task 5: Security and Error Handling
- [ ] Add connection security validation
- [ ] Implement proper error handling
- [ ] Add connection timeout handling
- [ ] Create connection logging

### Task 7: Testing
- [ ] Test PostgreSQL connection functionality
- [ ] Test data retrieval and manipulation
- [ ] Test configuration interface
- [ ] Test error handling scenarios
- [ ] Verify all tests pass with 90%+ coverage
- [ ] Run integration tests with real PostgreSQL database

### Task 8: Documentation
- [ ] Document PostgreSQL plugin usage
- [ ] Create configuration examples
- [ ] Add troubleshooting guide
- [ ] Document security considerations

## Definition of Done
- [ ] **TDD Complete**: All tests written before implementation and passing
- [ ] PostgreSQL datasource plugin with connection management is created
- [ ] Connection testing and validation is implemented
- [ ] Datasource configuration interface is created
- [ ] PostgreSQL plugin integrates with existing metadata system
- [ ] Support for PostgreSQL-specific features (schemas, etc.) is implemented
- [ ] PostgreSQL datasource works with existing view plugins
- [ ] Connection management is robust and handles errors gracefully
- [ ] Configuration interface is user-friendly and secure
- [ ] **Test Coverage**: 90%+ test coverage achieved
- [ ] **Test Quality**: All tests are meaningful and test actual functionality

## Risk Assessment
**Risk:** PostgreSQL connection issues may impact system stability
**Mitigation:** Comprehensive error handling, connection pooling, fallback mechanisms

## Dependencies
- Story 1.2: Implement Plugin Manager with pluggy (must be completed first)

## Next Stories
- Story 2.4: Implement MySQL Datasource Plugin
- Story 6.1: Create User Documentation 