# Story 2.4: Implement MySQL Datasource Plugin

## Epic Context
**Epic:** Epic 2: Plugin System Implementation  
**Epic Goal:** Implement extensible plugin system for views and datasources

## Story Details
**Priority:** Low  
**Effort:** Large  
**Dependencies:** Story 1.2 (Implement Plugin Manager with pluggy)

## User Story
As a developer,
I want to implement a MySQL datasource plugin with connection management,
so that users can connect to MySQL databases while maintaining SQLite as the default.

## Acceptance Criteria
1. Create MySQL datasource plugin with connection management
2. Implement connection testing and validation
3. MySQL plugin integrates with existing metadata system
4. Support for MySQL-specific features
5. Consistent interface with PostgreSQL plugin

## Integration Verification
- MySQL datasource works with existing view plugins
- Connection management is robust and handles errors gracefully
- Configuration interface is consistent with PostgreSQL plugin

## Technical Requirements

### MySQL Datasource Plugin
```python
# src/plugins/examples/mysql_datasource_plugin.py
import pluggy
import mysql.connector
from mysql.connector import Error
from typing import Dict, List, Any, Type, Tuple, Optional
from components.datasources.base_datasource import BaseDatasource
import logging

hookimpl = pluggy.HookimplMarker("nocoflo")

class MySQLDatasourcePlugin:
    @hookimpl
    def get_datasource_class(self) -> Type[BaseDatasource]:
        return MySQLDatasource
    
    @hookimpl
    def get_supported_schemes(self) -> List[str]:
        return ["mysql", "mariadb"]
    
    @hookimpl
    def get_datasource_name(self) -> str:
        return "MySQL Datasource"
    
    @hookimpl
    def get_datasource_description(self) -> str:
        return "Connect to MySQL and MariaDB databases with full support"

class MySQLDatasource(BaseDatasource):
    def __init__(self, connection_config: Dict[str, Any]):
        super().__init__(connection_config)
        self.connection = None
        self.cursor = None
        self.database = connection_config.get('database', '')
        self.charset = connection_config.get('charset', 'utf8mb4')
        self.ssl_disabled = connection_config.get('ssl_disabled', False)
        
    def connect(self) -> bool:
        """Establish connection to MySQL database"""
        try:
            self.connection = mysql.connector.connect(
                host=self.connection_config.get('host', 'localhost'),
                port=self.connection_config.get('port', 3306),
                user=self.connection_config.get('username', ''),
                password=self.connection_config.get('password', ''),
                database=self.database,
                charset=self.charset,
                ssl_disabled=self.ssl_disabled,
                autocommit=True
            )
            
            self.cursor = self.connection.cursor(dictionary=True)
            
            # Test connection
            self.cursor.execute("SELECT VERSION()")
            version = self.cursor.fetchone()
            logging.info(f"Connected to MySQL: {version['VERSION()']}")
            
            return True
            
        except Error as e:
            logging.error(f"MySQL connection failed: {str(e)}")
            return False
    
    def disconnect(self):
        """Close MySQL connection"""
        if self.cursor:
            self.cursor.close()
        if self.connection:
            self.connection.close()
    
    def test_connection(self, connection_config: Dict[str, Any]) -> bool:
        """Test MySQL connection"""
        try:
            # Create temporary connection for testing
            test_conn = mysql.connector.connect(
                host=connection_config.get('host', 'localhost'),
                port=connection_config.get('port', 3306),
                user=connection_config.get('username', ''),
                password=connection_config.get('password', ''),
                database=connection_config.get('database', ''),
                charset=connection_config.get('charset', 'utf8mb4'),
                ssl_disabled=connection_config.get('ssl_disabled', False)
            )
            test_cursor = test_conn.cursor()
            test_cursor.execute("SELECT 1")
            test_cursor.fetchone()
            test_cursor.close()
            test_conn.close()
            return True
        except Error as e:
            logging.error(f"MySQL connection test failed: {str(e)}")
            return False
    
    def get_table_data(self, table_config: Dict[str, Any], limit: int = 100) -> Tuple[List[str], List[Tuple]]:
        """Retrieve data from MySQL table"""
        if not self.connection:
            if not self.connect():
                raise Exception("Failed to connect to MySQL")
        
        try:
            table_name = table_config.get('table_name')
            database = table_config.get('database', self.database)
            
            # Get column information
            columns_query = """
                SELECT COLUMN_NAME, DATA_TYPE, IS_NULLABLE, COLUMN_DEFAULT
                FROM INFORMATION_SCHEMA.COLUMNS
                WHERE TABLE_SCHEMA = %s AND TABLE_NAME = %s
                ORDER BY ORDINAL_POSITION
            """
            self.cursor.execute(columns_query, (database, table_name))
            columns_info = self.cursor.fetchall()
            
            # Extract column names
            columns = [col['COLUMN_NAME'] for col in columns_info]
            
            # Get data with limit
            data_query = f"""
                SELECT * FROM `{database}`.`{table_name}`
                LIMIT %s
            """
            self.cursor.execute(data_query, (limit,))
            data = self.cursor.fetchall()
            
            # Convert to tuples
            data_tuples = [tuple(row.values()) for row in data]
            
            return columns, data_tuples
            
        except Error as e:
            logging.error(f"Error retrieving MySQL data: {str(e)}")
            raise
    
    def update_cell(self, table_config: Dict[str, Any], pk_col: str, pk_value: str, column: str, new_value: Any) -> bool:
        """Update cell value in MySQL table"""
        if not self.connection:
            if not self.connect():
                return False
        
        try:
            table_name = table_config.get('table_name')
            database = table_config.get('database', self.database)
            
            # Build update query
            update_query = f"""
                UPDATE `{database}`.`{table_name}`
                SET `{column}` = %s
                WHERE `{pk_col}` = %s
            """
            
            self.cursor.execute(update_query, (new_value, pk_value))
            self.connection.commit()
            
            return self.cursor.rowcount > 0
            
        except Error as e:
            logging.error(f"Error updating MySQL cell: {str(e)}")
            self.connection.rollback()
            return False
    
    def insert_row(self, table_config: Dict[str, Any], data: Dict[str, Any]) -> bool:
        """Insert new row into MySQL table"""
        if not self.connection:
            if not self.connect():
                return False
        
        try:
            table_name = table_config.get('table_name')
            database = table_config.get('database', self.database)
            
            # Build insert query
            columns = list(data.keys())
            values = list(data.values())
            placeholders = ', '.join(['%s'] * len(columns))
            
            insert_query = f"""
                INSERT INTO `{database}`.`{table_name}` (`{'`, `'.join(columns)}`)
                VALUES ({placeholders})
            """
            
            self.cursor.execute(insert_query, values)
            self.connection.commit()
            
            return True
            
        except Error as e:
            logging.error(f"Error inserting MySQL row: {str(e)}")
            self.connection.rollback()
            return False
    
    def delete_row(self, table_config: Dict[str, Any], pk_col: str, pk_value: str) -> bool:
        """Delete row from MySQL table"""
        if not self.connection:
            if not self.connect():
                return False
        
        try:
            table_name = table_config.get('table_name')
            database = table_config.get('database', self.database)
            
            # Build delete query
            delete_query = f"""
                DELETE FROM `{database}`.`{table_name}`
                WHERE `{pk_col}` = %s
            """
            
            self.cursor.execute(delete_query, (pk_value,))
            self.connection.commit()
            
            return self.cursor.rowcount > 0
            
        except Error as e:
            logging.error(f"Error deleting MySQL row: {str(e)}")
            self.connection.rollback()
            return False
    
    def get_schema(self, table_config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Get table schema from MySQL"""
        if not self.connection:
            if not self.connect():
                return []
        
        try:
            table_name = table_config.get('table_name')
            database = table_config.get('database', self.database)
            
            # Get detailed column information
            schema_query = """
                SELECT 
                    COLUMN_NAME,
                    DATA_TYPE,
                    IS_NULLABLE,
                    COLUMN_DEFAULT,
                    CHARACTER_MAXIMUM_LENGTH,
                    NUMERIC_PRECISION,
                    NUMERIC_SCALE,
                    COLUMN_KEY,
                    EXTRA
                FROM INFORMATION_SCHEMA.COLUMNS
                WHERE TABLE_SCHEMA = %s AND TABLE_NAME = %s
                ORDER BY ORDINAL_POSITION
            """
            
            self.cursor.execute(schema_query, (database, table_name))
            columns_info = self.cursor.fetchall()
            
            schema = []
            for col in columns_info:
                schema.append({
                    'name': col['COLUMN_NAME'],
                    'type': col['DATA_TYPE'],
                    'nullable': col['IS_NULLABLE'] == 'YES',
                    'default': col['COLUMN_DEFAULT'],
                    'max_length': col['CHARACTER_MAXIMUM_LENGTH'],
                    'precision': col['NUMERIC_PRECISION'],
                    'scale': col['NUMERIC_SCALE'],
                    'key': col['COLUMN_KEY'],
                    'extra': col['EXTRA']
                })
            
            return schema
            
        except Error as e:
            logging.error(f"Error getting MySQL schema: {str(e)}")
            return []
    
    def get_available_tables(self) -> List[Dict[str, Any]]:
        """Get list of available tables in MySQL"""
        if not self.connection:
            if not self.connect():
                return []
        
        try:
            # Get tables from current database
            tables_query = """
                SELECT 
                    TABLE_NAME,
                    TABLE_TYPE,
                    TABLE_ROWS,
                    DATA_LENGTH,
                    INDEX_LENGTH
                FROM INFORMATION_SCHEMA.TABLES
                WHERE TABLE_SCHEMA = %s
                ORDER BY TABLE_NAME
            """
            
            self.cursor.execute(tables_query, (self.database,))
            tables = self.cursor.fetchall()
            
            available_tables = []
            for table in tables:
                if table['TABLE_TYPE'] == 'BASE TABLE':
                    available_tables.append({
                        'name': table['TABLE_NAME'],
                        'database': self.database,
                        'row_count': table['TABLE_ROWS'] or 0,
                        'data_size': table['DATA_LENGTH'] or 0,
                        'index_size': table['INDEX_LENGTH'] or 0,
                        'type': 'table'
                    })
            
            return available_tables
            
        except Error as e:
            logging.error(f"Error getting MySQL tables: {str(e)}")
            return []
    
    def get_available_databases(self) -> List[str]:
        """Get list of available databases in MySQL"""
        if not self.connection:
            if not self.connect():
                return []
        
        try:
            databases_query = """
                SELECT SCHEMA_NAME
                FROM INFORMATION_SCHEMA.SCHEMATA
                WHERE SCHEMA_NAME NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
                ORDER BY SCHEMA_NAME
            """
            
            self.cursor.execute(databases_query)
            databases = self.cursor.fetchall()
            
            return [db['SCHEMA_NAME'] for db in databases]
            
        except Error as e:
            logging.error(f"Error getting MySQL databases: {str(e)}")
            return []
    
    def execute_custom_query(self, query: str, parameters: Tuple = None) -> Tuple[List[str], List[Tuple]]:
        """Execute custom SQL query"""
        if not self.connection:
            if not self.connect():
                raise Exception("Failed to connect to MySQL")
        
        try:
            self.cursor.execute(query, parameters or ())
            
            if self.cursor.description:
                # SELECT query
                columns = [desc[0] for desc in self.cursor.description]
                data = [tuple(row.values()) for row in self.cursor.fetchall()]
                return columns, data
            else:
                # INSERT/UPDATE/DELETE query
                self.connection.commit()
                return [], []
                
        except Error as e:
            logging.error(f"Error executing custom MySQL query: {str(e)}")
            self.connection.rollback()
            raise
    
    def get_table_size(self, table_name: str) -> Dict[str, Any]:
        """Get table size information"""
        if not self.connection:
            if not self.connect():
                return {}
        
        try:
            size_query = """
                SELECT 
                    TABLE_NAME,
                    TABLE_ROWS,
                    DATA_LENGTH,
                    INDEX_LENGTH,
                    (DATA_LENGTH + INDEX_LENGTH) as TOTAL_SIZE
                FROM INFORMATION_SCHEMA.TABLES
                WHERE TABLE_SCHEMA = %s AND TABLE_NAME = %s
            """
            
            self.cursor.execute(size_query, (self.database, table_name))
            result = self.cursor.fetchone()
            
            if result:
                return {
                    'table_name': result['TABLE_NAME'],
                    'row_count': result['TABLE_ROWS'] or 0,
                    'data_size': result['DATA_LENGTH'] or 0,
                    'index_size': result['INDEX_LENGTH'] or 0,
                    'total_size': result['TOTAL_SIZE'] or 0
                }
            
            return {}
            
        except Error as e:
            logging.error(f"Error getting MySQL table size: {str(e)}")
            return {}
```

### MySQL Configuration Interface
```python
# src/pages/admin/mysql_configuration.py
from nicegui import ui, app
from typing import Dict, List, Any, Optional
from components.common.auth import AuthManager
from components.datasources.base_datasource import BaseDatasource

@ui.page('/admin/mysql')
def mysql_configuration():
    """MySQL configuration interface"""
    auth = AuthManager()
    
    # Require admin authentication
    if not auth.require_auth('/login') or not auth.is_admin():
        ui.navigate.to('/login')
        return
    
    # Header
    with ui.header().classes('bg-primary text-white'):
        ui.label('MySQL Configuration').classes('text-xl font-bold')
    
    # Main content
    with ui.column().classes('w-full p-6'):
        # Connection configuration
        with ui.card().classes('w-full mb-6'):
            ui.label('Connection Settings').classes('text-lg font-semibold mb-4')
            
            with ui.column().classes('w-full gap-4'):
                # Host and port
                with ui.row().classes('w-full gap-4'):
                    host_input = ui.input('Host', value='localhost').classes('flex-1')
                    port_input = ui.input('Port', value='3306').classes('flex-1')
                
                # Database and credentials
                with ui.row().classes('w-full gap-4'):
                    database_input = ui.input('Database').classes('flex-1')
                    username_input = ui.input('Username').classes('flex-1')
                    password_input = ui.input('Password', password=True).classes('flex-1')
                
                # Character set and SSL
                with ui.row().classes('w-full gap-4'):
                    charset_select = ui.select('Character Set', options=['utf8mb4', 'utf8', 'latin1']).classes('flex-1')
                    ssl_checkbox = ui.checkbox('Disable SSL').classes('flex-1')
                
                # Test connection button
                test_button = ui.button('Test Connection', on_click=lambda: test_connection())
        
        # Connection status
        with ui.card().classes('w-full mb-6'):
            ui.label('Connection Status').classes('text-lg font-semibold mb-4')
            
            status_container = ui.column().classes('w-full')
        
        # Available tables
        with ui.card().classes('w-full mb-6'):
            ui.label('Available Tables').classes('text-lg font-semibold mb-4')
            
            tables_container = ui.column().classes('w-full')
        
        # Available databases
        with ui.card().classes('w-full mb-6'):
            ui.label('Available Databases').classes('text-lg font-semibold mb-4')
            
            databases_container = ui.column().classes('w-full')
    
    def test_connection():
        """Test MySQL connection"""
        try:
            # Build connection config
            config = {
                'host': host_input.value,
                'port': int(port_input.value),
                'database': database_input.value,
                'username': username_input.value,
                'password': password_input.value,
                'charset': charset_select.value,
                'ssl_disabled': ssl_checkbox.value
            }
            
            # Test connection
            from plugins.examples.mysql_datasource_plugin import MySQLDatasource
            datasource = MySQLDatasource(config)
            
            if datasource.test_connection(config):
                ui.notify('✅ Connection successful!', type='positive')
                load_connection_info()
            else:
                ui.notify('❌ Connection failed', type='negative')
                
        except Exception as e:
            ui.notify(f'❌ Connection error: {str(e)}', type='negative')
    
    def load_connection_info():
        """Load connection information after successful connection"""
        try:
            # Build connection config
            config = {
                'host': host_input.value,
                'port': int(port_input.value),
                'database': database_input.value,
                'username': username_input.value,
                'password': password_input.value,
                'charset': charset_select.value,
                'ssl_disabled': ssl_checkbox.value
            }
            
            # Create datasource
            from plugins.examples.mysql_datasource_plugin import MySQLDatasource
            datasource = MySQLDatasource(config)
            
            if datasource.connect():
                # Update status
                status_container.clear()
                with status_container:
                    ui.label('✅ Connected').classes('text-green-600 font-semibold')
                    ui.label(f"Host: {config['host']}:{config['port']}")
                    ui.label(f"Database: {config['database']}")
                    ui.label(f"Character Set: {config['charset']}")
                
                # Load tables
                tables_container.clear()
                tables = datasource.get_available_tables()
                with tables_container:
                    if tables:
                        with ui.table().classes('w-full'):
                            ui.table_column('Table Name', 'name')
                            ui.table_column('Database', 'database')
                            ui.table_column('Row Count', 'row_count')
                            ui.table_column('Size', 'size')
                            
                            for table in tables:
                                size_mb = (table['data_size'] + table['index_size']) / 1024 / 1024
                                with ui.table_row():
                                    ui.table_cell(table['name'])
                                    ui.table_cell(table['database'])
                                    ui.table_cell(str(table['row_count']))
                                    ui.table_cell(f"{size_mb:.1f} MB")
                    else:
                        ui.label('No tables found')
                
                # Load databases
                databases_container.clear()
                databases = datasource.get_available_databases()
                with databases_container:
                    if databases:
                        for database in databases:
                            ui.label(f"• {database}")
                    else:
                        ui.label('No databases found')
                
                datasource.disconnect()
                
        except Exception as e:
            ui.notify(f'❌ Error loading connection info: {str(e)}', type='negative')
```

## Implementation Tasks

### Task 1: Create MySQL Datasource Plugin
- [ ] Create `src/plugins/examples/mysql_datasource_plugin.py`
- [ ] Implement MySQL connection management
- [ ] Add connection testing and validation
- [ ] Implement data retrieval and manipulation methods

### Task 2: Add MySQL Configuration Interface
- [ ] Create `src/pages/admin/mysql_configuration.py`
- [ ] Implement connection configuration form
- [ ] Add connection testing functionality
- [ ] Create table and database discovery

### Task 3: Integrate with Plugin System
- [ ] Register MySQL plugin with plugin manager
- [ ] Add MySQL support to datasource selection
- [ ] Implement plugin configuration storage
- [ ] Add plugin validation for MySQL

### Task 4: Add MySQL-Specific Features
- [ ] Implement character set support
- [ ] Add SSL configuration
- [ ] Support for custom queries
- [ ] Add connection pooling

### Task 5: Security and Error Handling
- [ ] Add connection security validation
- [ ] Implement proper error handling
- [ ] Add connection timeout handling
- [ ] Create connection logging

### Task 6: Testing
- [ ] Test MySQL connection functionality
- [ ] Test data retrieval and manipulation
- [ ] Test configuration interface
- [ ] Test error handling scenarios

### Task 7: Documentation
- [ ] Document MySQL plugin usage
- [ ] Create configuration examples
- [ ] Add troubleshooting guide
- [ ] Document security considerations

## Definition of Done
- [ ] MySQL datasource plugin with connection management is created
- [ ] Connection testing and validation is implemented
- [ ] MySQL plugin integrates with existing metadata system
- [ ] Support for MySQL-specific features is implemented
- [ ] Consistent interface with PostgreSQL plugin is maintained
- [ ] MySQL datasource works with existing view plugins
- [ ] Connection management is robust and handles errors gracefully
- [ ] Configuration interface is consistent with PostgreSQL plugin
- [ ] Tests cover MySQL plugin functionality

## Risk Assessment
**Risk:** MySQL connection issues may impact system stability
**Mitigation:** Comprehensive error handling, connection pooling, fallback mechanisms

## Dependencies
- Story 1.2: Implement Plugin Manager with pluggy (must be completed first)

## Next Stories
- Story 6.1: Create User Documentation
- Story 6.2: Create Developer Documentation 