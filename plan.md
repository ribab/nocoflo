# Nocoflo Refactoring Plan: Components & Plugin System

THIS WAS GENERATED BY AI (need to review, don't like this plan 100%. maybe chatgpt can make it better)

## Overview
Refactor the current monolithic structure into a component-based architecture with a plugin system using `pluggy` to support:
- Multiple view types (table, chart, form, etc.)
- Multiple datasources (SQLite, PostgreSQL, MySQL, REST APIs, etc.)

## Current Structure Analysis

### Current Files:
- `layout_template.py` - Main layout with navigation, headers, drawers
- `table_view.py` - Table viewing and editing functionality  
- `metadata.py` - Database and metadata management
- `pages/*.py` - Various page handlers

### Issues with Current Structure:
1. Tight coupling between UI components and business logic
2. Hard-coded table view as the only view type
3. SQLite-only datasource support
4. Difficult to extend without modifying core files

## Refactoring Plan

### Phase 1: Component Structure

#### 1.1 Create Component Directories
```
components/
├── layout/
│   ├── __init__.py
│   ├── header.py           # Header component with menu, user info, logout
│   ├── left_drawer.py      # Navigation drawer with databases/tables
│   ├── right_drawer.py     # Admin settings drawer
│   └── base_layout.py      # Main layout orchestrator
├── views/
│   ├── __init__.py
│   ├── base_view.py        # Abstract base view class
│   └── table_view.py       # Table view component (moved from pages/)
├── datasources/
│   ├── __init__.py
│   ├── base_datasource.py  # Abstract base datasource class
│   └── sqlite_datasource.py # SQLite implementation
└── common/
    ├── __init__.py
    ├── permissions.py      # Permission checking utilities
    ├── locks.py           # Row locking utilities
    └── audit.py           # Change logging utilities
```

#### 1.2 Component Interfaces

**Base Layout Component (`components/layout/base_layout.py`)**
```python
class BaseLayout:
    def __init__(self, content_func: Callable, table_id: Optional[int] = None)
    def render(self) -> None
    def get_user_tables(self) -> List[Dict]
    def show_table_menu(self, table: Dict) -> None
```

**Base View Component (`components/views/base_view.py`)**
```python
class BaseView(ABC):
    def __init__(self, table_id: int, datasource: BaseDatasource)
    
    @abstractmethod
    def render(self) -> None
    
    @abstractmethod
    def get_view_name(self) -> str
    
    @abstractmethod
    def can_handle_table(self, table_meta: Dict) -> bool
```

**Base Datasource Component (`components/datasources/base_datasource.py`)**
```python
class BaseDatasource(ABC):
    @abstractmethod
    def get_table_data(self, table_config: Dict, limit: int = 100) -> Tuple[List[str], List[Tuple]]
    
    @abstractmethod
    def update_cell(self, table_config: Dict, pk_col: str, pk_value: str, column: str, new_value: Any) -> bool
    
    @abstractmethod
    def insert_row(self, table_config: Dict, data: Dict) -> bool
    
    @abstractmethod
    def delete_row(self, table_config: Dict, pk_col: str, pk_value: str) -> bool
    
    @abstractmethod
    def get_schema(self, table_config: Dict) -> List[Dict]
    
    @abstractmethod
    def test_connection(self, connection_config: Dict) -> bool
```

### Phase 2: Plugin System Implementation

#### 2.1 Plugin Architecture using Pluggy

**Plugin Manager (`plugins/plugin_manager.py`)**
```python
import pluggy
from .hookspecs import ViewHookSpec, DatasourceHookSpec

class PluginManager:
    def __init__(self):
        self.pm = pluggy.PluginManager("nocoflo")
        self.pm.add_hookspecs(ViewHookSpec)
        self.pm.add_hookspecs(DatasourceHookSpec)
        self.load_default_plugins()
        self.load_external_plugins()
    
    def get_available_views(self, table_meta: Dict) -> List[BaseView]
    def get_datasource(self, datasource_type: str) -> BaseDatasource
    def register_plugin(self, plugin: Any) -> None
```

**Hook Specifications (`plugins/hookspecs.py`)**
```python
import pluggy

hookspec = pluggy.HookspecMarker("nocoflo")

class ViewHookSpec:
    @hookspec
    def get_view_class(self) -> Type[BaseView]:
        """Return the view class this plugin provides"""
        
    @hookspec  
    def get_view_priority(self) -> int:
        """Return priority for view selection (higher = preferred)"""

class DatasourceHookSpec:
    @hookspec
    def get_datasource_class(self) -> Type[BaseDatasource]:
        """Return the datasource class this plugin provides"""
        
    @hookspec
    def get_supported_schemes(self) -> List[str]:
        """Return list of connection string schemes this datasource supports"""
```

#### 2.2 Default Plugins

**Table View Plugin (`plugins/default/table_view_plugin.py`)**
```python
import pluggy
from components.views.base_view import BaseView
from components.views.table_view import TableView

hookimpl = pluggy.HookimplMarker("nocoflo")

class TableViewPlugin:
    @hookimpl
    def get_view_class(self) -> Type[BaseView]:
        return TableView
    
    @hookimpl
    def get_view_priority(self) -> int:
        return 1  # Default fallback priority
```

**SQLite Datasource Plugin (`plugins/default/sqlite_datasource_plugin.py`)**
```python
import pluggy
from components.datasources.base_datasource import BaseDatasource
from components.datasources.sqlite_datasource import SQLiteDatasource

hookimpl = pluggy.HookimplMarker("nocoflo")

class SQLiteDatasourcePlugin:
    @hookimpl
    def get_datasource_class(self) -> Type[BaseDatasource]:
        return SQLiteDatasource
    
    @hookimpl
    def get_supported_schemes(self) -> List[str]:
        return ["sqlite", "sqlite3"]
```

#### 2.3 Plugin Directory Structure
```
plugins/
├── __init__.py
├── plugin_manager.py
├── hookspecs.py
├── default/
│   ├── __init__.py
│   ├── table_view_plugin.py
│   └── sqlite_datasource_plugin.py
└── external/
    ├── __init__.py
    └── (external plugins loaded from here)
```

### Phase 3: Extended Plugin Examples

#### 3.1 Additional View Plugins

**Chart View Plugin (`plugins/examples/chart_view_plugin.py`)**
```python
class ChartView(BaseView):
    def render(self) -> None:
        # Render charts using plotly/matplotlib
        pass
    
    def can_handle_table(self, table_meta: Dict) -> bool:
        # Check if table has numeric columns suitable for charting
        return self.has_numeric_columns(table_meta)
```

**Form View Plugin (`plugins/examples/form_view_plugin.py`)**
```python
class FormView(BaseView):
    def render(self) -> None:
        # Render as forms for single-record editing
        pass
    
    def can_handle_table(self, table_meta: Dict) -> bool:
        # Good for tables with many columns or complex relationships
        return len(table_meta.get('columns', [])) > 10
```

#### 3.2 Additional Datasource Plugins

**PostgreSQL Datasource Plugin (`plugins/examples/postgres_datasource_plugin.py`)**
```python
class PostgreSQLDatasource(BaseDatasource):
    def get_supported_schemes(self) -> List[str]:
        return ["postgresql", "postgres"]
    
    def get_table_data(self, table_config: Dict, limit: int = 100) -> Tuple[List[str], List[Tuple]]:
        # PostgreSQL-specific implementation
        pass
```

**REST API Datasource Plugin (`plugins/examples/rest_api_datasource_plugin.py`)**
```python
class RestApiDatasource(BaseDatasource):
    def get_supported_schemes(self) -> List[str]:
        return ["http", "https"]
    
    def get_table_data(self, table_config: Dict, limit: int = 100) -> Tuple[List[str], List[Tuple]]:
        # REST API implementation with pagination
        pass
```

### Phase 4: Integration Changes

#### 4.1 Update Core Files

**Modified `metadata.py`**
- Move datasource-specific logic to plugins
- Keep only metadata management
- Add plugin configuration storage

**Modified `layout_template.py`**
- Use component-based layout
- Support multiple view types in navigation
- Dynamic view selection based on available plugins

**Updated `pages/table_view.py`**
- Becomes a route handler that delegates to plugin manager
- Determines best view plugin for the table
- Handles view switching

#### 4.2 Configuration Updates

**Add to `config.py`**
```python
PLUGIN_CONFIG = {
    'enabled_plugins': ['table_view', 'sqlite_datasource'],
    'plugin_directories': ['plugins/default', 'plugins/external'],
    'view_selection_strategy': 'auto',  # 'auto', 'manual', 'priority'
}
```

### Phase 5: Database Schema Extensions

#### 5.1 New Metadata Tables
```sql
-- Plugin configurations
CREATE TABLE plugin_config (
    id INTEGER PRIMARY KEY,
    plugin_name TEXT NOT NULL,
    config_json TEXT,
    enabled INTEGER DEFAULT 1
);

-- View preferences per table
CREATE TABLE table_view_preference (
    id INTEGER PRIMARY KEY,
    table_id INTEGER,
    user_id INTEGER,
    preferred_view TEXT,
    view_config_json TEXT,
    FOREIGN KEY (table_id) REFERENCES table_meta(id),
    FOREIGN KEY (user_id) REFERENCES user(id)
);

-- Extended datasource configurations
ALTER TABLE dbconfig ADD COLUMN datasource_type TEXT DEFAULT 'sqlite';
ALTER TABLE dbconfig ADD COLUMN config_json TEXT;
```

### Phase 6: Migration Strategy

#### 6.1 Backwards Compatibility
1. Keep existing interfaces working during transition
2. Gradual migration of functionality to plugins
3. Feature flags to enable/disable new plugin system

#### 6.2 Migration Steps
1. Create component structure
2. Move existing functionality to default plugins
3. Implement plugin manager
4. Update routing to use plugin manager
5. Add configuration for plugin management
6. Test with existing data
7. Add example plugins
8. Documentation and developer guide

### Phase 7: Developer Experience

#### 7.1 Plugin Development Kit
- Plugin template generator
- Development documentation
- Testing utilities
- Hot-reload support for plugin development

#### 7.2 Plugin Management UI
- Admin interface for enabling/disabling plugins
- Plugin configuration interface
- Plugin marketplace/discovery (future)

## Benefits of This Architecture

1. **Extensibility**: Easy to add new view types and datasources
2. **Maintainability**: Clear separation of concerns
3. **Testability**: Components can be tested in isolation
4. **Reusability**: Components can be reused across different contexts
5. **Community**: Others can contribute plugins without modifying core
6. **Flexibility**: Users can customize their experience with plugin selection

## Implementation Priority

1. **High Priority**: Component structure, plugin manager, default plugins
2. **Medium Priority**: Additional view/datasource plugins, plugin management UI
3. **Low Priority**: Plugin marketplace, advanced configuration options

This architecture will transform Nocoflo from a rigid table viewer into a flexible, extensible data exploration platform.
